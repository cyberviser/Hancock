"""
YARA Rule Knowledge Base — Hancock CyberViser
Q&A pairs for YARA rule authoring and malware detection engineering.
Outputs: data/raw_yara_kb.json
"""
import json
from pathlib import Path

OUTPUT_FILE = Path(__file__).parent.parent / "data" / "raw_yara_kb.json"

HANCOCK_SYSTEM = (
    "You are Hancock YARA, CyberViser's expert malware analyst and detection engineer. "
    "Your expertise covers YARA rule syntax (meta, strings, conditions), malware families, "
    "file-format artefacts, memory scanning, and YARA modules (pe, elf, math, hash). "
    "You always output complete, syntactically valid YARA rules with proper meta, "
    "multiple string conditions to reduce false positives, and a clear explanation. "
    "Every rule you write is ready to run with 'yara64 -r rule.yar /path'."
)

KB = [
    # ── YARA BASICS ──────────────────────────────────────────────────────────────
    {
        "category": "yara_basics",
        "user": "Explain YARA rule structure with all syntax elements and a complete example.",
        "assistant": (
            "**YARA Rule Structure — Complete Reference**\n\n"
            "```yara\n"
            "rule RuleName : tag1 tag2 {\n"
            "    meta:\n"
            "        description = \"What this rule detects\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        version     = \"1.0\"\n"
            "        hash        = \"sha256_of_sample_if_known\"\n"
            "        reference   = \"https://example.com/malware-report\"\n"
            "        severity    = \"high\"\n"
            "        tlp         = \"white\"\n"
            "\n"
            "    strings:\n"
            "        // Hex patterns (byte sequences)\n"
            "        $hex1 = { 4D 5A 90 00 03 }       // PE magic bytes (MZ)\n"
            "        $hex2 = { 48 65 6C 6C 6F }        // 'Hello' in hex\n"
            "        $hex3 = { 48 [2] 6C 6C 6F }       // with 2-byte wildcard\n"
            "        $hex4 = { 48 ?? 6C 6C 6F }        // with 1-byte wildcard\n"
            "\n"
            "        // ASCII strings\n"
            "        $str1 = \"malware.exe\"\n"
            "        $str2 = \"C:\\\\Windows\\\\Temp\\\\\" nocase\n"
            "        $str3 = \"http://c2server.\" nocase wide  // wide = UTF-16LE\n"
            "        $str4 = /https?:\\/\\/[a-z0-9]{8,12}\\.tk/  // regex\n"
            "\n"
            "        // String modifiers: nocase, wide, ascii, fullword, base64, xor\n"
            "        $str5 = \"CreateRemoteThread\" fullword\n"
            "        $str6 = \"payload\" base64 base64wide\n"
            "        $str7 = \"VirtualAlloc\" xor(1-255)  // detect XOR-obfuscated\n"
            "\n"
            "    condition:\n"
            "        // Operators: and, or, not, for, all of, any of, X of\n"
            "        uint16(0) == 0x5A4D and         // PE file check\n"
            "        filesize < 5MB and\n"
            "        (\n"
            "            2 of ($str*) or\n"
            "            all of ($hex*)\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**Key Condition Functions**\n"
            "| Function | Example | Purpose |\n"
            "|----------|---------|----------|\n"
            "| `uint8(offset)` | `uint8(0) == 0x4D` | Read 1 byte at offset |\n"
            "| `uint16(offset)` | `uint16(0) == 0x5A4D` | Read 2 bytes (little-endian) |\n"
            "| `uint32(offset)` | `uint32(0) == 0x464C457F` | ELF magic bytes |\n"
            "| `filesize` | `filesize < 1MB` | File size comparison |\n"
            "| `pe.imphash()` | `pe.imphash() == \"abc123\"` | Import hash match |\n"
            "| `pe.sections[0].name` | `pe.sections[0].name == \".text\"` | Section check |\n"
            "| `pe.imports(\"kernel32.dll\", \"VirtualAlloc\")` | API import check |\n"
            "| `math.entropy(0, filesize)` | `math.entropy(0, filesize) > 7.5` | Packed/encrypted content |\n"
            "| `#str1 > 5` | occurrence count | String appears 5+ times |\n"
            "| `@str1[0]` | first offset | Offset of first match |\n"
        ),
    },
    {
        "category": "yara_malware",
        "user": "Write a YARA rule to detect Mimikatz credential dumping tool.",
        "assistant": (
            "```yara\n"
            "rule Mimikatz_Credential_Dumper {\n"
            "    meta:\n"
            "        description = \"Detects Mimikatz credential dumping tool and its variants\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://attack.mitre.org/software/S0002/\"\n"
            "        hash        = \"fc525c9683e8fe067095ba2ddc971889\"\n"
            "\n"
            "    strings:\n"
            "        // Core Mimikatz strings\n"
            "        $mz = { 4D 5A }  // PE header\n"
            "        $s1 = \"mimikatz\" nocase\n"
            "        $s2 = \"mimilib\" nocase\n"
            "        $s3 = \"Benjamin Delpy\" nocase\n"
            "        $s4 = \"gentilkiwi\" nocase\n"
            "        $s5 = \"sekurlsa::\" nocase\n"
            "        $s6 = \"lsadump::\" nocase\n"
            "        $s7 = \"kerberos::\" nocase\n"
            "        $s8 = \"privilege::debug\" nocase\n"
            "        $s9 = \"Pass-the-Hash\" nocase\n"
            "\n"
            "        // API imports common in Mimikatz\n"
            "        $api1 = \"LsaUnprotectMemory\" fullword\n"
            "        $api2 = \"MiniDumpWriteDump\" fullword\n"
            "        $api3 = \"NtlmSharedPasswordRequest\" fullword\n"
            "\n"
            "        // Obfuscated/packed variants — hex pattern in sekurlsa module\n"
            "        $hex1 = { 6D 73 76 31 5F 30 }  // 'msv1_0'\n"
            "        $hex2 = { 6C 73 61 73 72 76 2E 64 6C 6C }  // 'lsasrv.dll'\n"
            "\n"
            "    condition:\n"
            "        $mz at 0 and\n"
            "        filesize < 10MB and\n"
            "        (\n"
            "            3 of ($s*) or\n"
            "            (1 of ($s1, $s2, $s3, $s4) and 1 of ($api*)) or\n"
            "            (2 of ($s5, $s6, $s7, $s8) and 1 of ($hex*))\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**What this detects:** Mimikatz binary (original and common forks), including obfuscated "
            "variants that retain the core module command strings.\n\n"
            "**Known false positives:** Security research tools, LSASS diagnostic utilities. "
            "Should be near-zero in production environments.\n\n"
            "**Limitations:** Heavily obfuscated/custom Mimikatz forks may evade string-based detection. "
            "For those, use behavioral detection (process access to LSASS) rather than static YARA.\n\n"
            "**Usage:**\n"
            "```bash\n"
            "yara64 -r mimikatz.yar /path/to/scan\n"
            "# Or scan memory with volatility:\n"
            "# vol.py yarascan --yara-file=mimikatz.yar -p <PID>\n"
            "```"
        ),
    },
    {
        "category": "yara_malware",
        "user": "Write a YARA rule to detect ransomware behavior patterns.",
        "assistant": (
            "```yara\n"
            "rule Ransomware_Generic_Indicators {\n"
            "    meta:\n"
            "        description = \"Detects generic ransomware behavioral indicators: shadow copy deletion, ransom notes, encryption API usage\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1490/\"\n"
            "\n"
            "    strings:\n"
            "        // Shadow copy deletion — common ransomware evasion\n"
            "        $shadow1 = \"vssadmin delete shadows\" nocase\n"
            "        $shadow2 = \"vssadmin.exe delete\" nocase\n"
            "        $shadow3 = \"wmic shadowcopy delete\" nocase\n"
            "        $shadow4 = { 76 73 73 61 64 6D 69 6E }  // 'vssadmin' hex\n"
            "\n"
            "        // Ransom note indicators\n"
            "        $note1 = \"YOUR FILES HAVE BEEN ENCRYPTED\" nocase\n"
            "        $note2 = \"All your files\" nocase\n"
            "        $note3 = \"bitcoin\" nocase\n"
            "        $note4 = \"decrypt\" nocase\n"
            "        $note5 = \"tor browser\" nocase\n"
            "        $note6 = \"onion\" nocase\n"
            "\n"
            "        // Windows crypto API usage\n"
            "        $api1 = \"CryptEncrypt\" fullword\n"
            "        $api2 = \"CryptGenKey\" fullword\n"
            "        $api3 = \"BCryptEncrypt\" fullword\n"
            "        $api4 = \"BCryptGenerateSymmetricKey\" fullword\n"
            "\n"
            "        // File operations\n"
            "        $file1 = \".locked\" nocase\n"
            "        $file2 = \".encrypted\" nocase\n"
            "        $file3 = \"!decrypt\" nocase\n"
            "        $file4 = \"README_FILES\" nocase\n"
            "        $file5 = \"HOW_TO_DECRYPT\" nocase\n"
            "\n"
            "        // Boot recovery disable\n"
            "        $boot1 = \"bcdedit /set {default} recoveryenabled No\" nocase\n"
            "        $boot2 = \"bcdedit /set {default} bootstatuspolicy ignoreallfailures\" nocase\n"
            "        $boot3 = \"wbadmin delete catalog\" nocase\n"
            "\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 20MB and\n"
            "        (\n"
            "            2 of ($shadow*) or\n"
            "            (1 of ($shadow*) and 1 of ($note*)) or\n"
            "            (2 of ($note*) and 1 of ($api*)) or\n"
            "            (1 of ($boot*) and 1 of ($api*)) or\n"
            "            (3 of ($note*, $file*))\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**What this detects:** Ransomware binaries that include shadow copy deletion commands, "
            "Windows crypto API calls, and ransom note strings — covering behavior across LockBit, "
            "REvil, Conti, BlackCat, and other common families.\n\n"
            "**False positives:** Backup software that references VSS, security awareness training materials. "
            "Rule is broad by design — tune by adjusting the condition combination thresholds.\n\n"
            "**Complement with:** Behavioral detection for high file-rename rates (MDE: DeviceFileEvents), "
            "and network rules for TOR traffic during the ransom note delivery phase."
        ),
    },
    {
        "category": "yara_malware",
        "user": "Write a YARA rule to detect a remote access trojan (RAT) dropper.",
        "assistant": (
            "```yara\n"
            "rule RAT_Dropper_Generic {\n"
            "    meta:\n"
            "        description = \"Detects generic RAT dropper characteristics: embedded payload, anti-analysis, process injection APIs\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1055/\"\n"
            "\n"
            "    strings:\n"
            "        // Process injection APIs\n"
            "        $inj1 = \"VirtualAllocEx\" fullword\n"
            "        $inj2 = \"WriteProcessMemory\" fullword\n"
            "        $inj3 = \"CreateRemoteThread\" fullword\n"
            "        $inj4 = \"NtCreateThreadEx\" fullword\n"
            "        $inj5 = \"QueueUserAPC\" fullword\n"
            "        $inj6 = \"ZwUnmapViewOfSection\" fullword\n"
            "\n"
            "        // Anti-analysis\n"
            "        $anti1 = \"IsDebuggerPresent\" fullword\n"
            "        $anti2 = \"CheckRemoteDebuggerPresent\" fullword\n"
            "        $anti3 = \"NtQueryInformationProcess\" fullword\n"
            "        $anti4 = \"GetTickCount\" fullword\n"
            "\n"
            "        // Persistence mechanisms\n"
            "        $persist1 = \"\\\\CurrentVersion\\\\Run\" nocase\n"
            "        $persist2 = \"\\\\CurrentVersion\\\\RunOnce\" nocase\n"
            "        $persist3 = \"schtasks /create\" nocase\n"
            "\n"
            "        // Network indicators\n"
            "        $net1 = \"Mozilla/\" nocase\n"
            "        $net2 = \"WinHttpConnect\" fullword\n"
            "        $net3 = \"InternetOpenUrl\" fullword\n"
            "        $net4 = \"URLDownloadToFile\" fullword\n"
            "\n"
            "        // Embedded payload markers\n"
            "        $pe_magic = { 4D 5A }  // MZ\n"
            "        $elf_magic = { 7F 45 4C 46 }  // ELF\n"
            "        $enc_pe = { 4E 5B }  // XOR-1 encoded MZ\n"
            "\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 15MB and\n"
            "        (\n"
            "            // Process injection + anti-analysis = strong dropper signal\n"
            "            (2 of ($inj*) and 1 of ($anti*)) or\n"
            "            // Injection + persistence + network\n"
            "            (2 of ($inj*) and 1 of ($persist*) and 1 of ($net*)) or\n"
            "            // Embedded PE + injection capability\n"
            "            ($pe_magic in (1024..filesize) and 2 of ($inj*))\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**What this detects:** Dropper executables that combine process injection APIs with "
            "anti-debugging, persistence, and C2 network calls — patterns consistent with RATs like "
            "AsyncRAT, njRAT, Quasar, AgentTesla, Remcos, and custom droppers.\n\n"
            "**False positives:** Legitimate software using `CreateRemoteThread` (some DLL injectors, "
            "game overlays, AV hooks). Reduce FPs by requiring 3+ conditions.\n\n"
            "**Performance tip:** Place `uint16(0) == 0x5A4D` and `filesize < 15MB` first — "
            "YARA evaluates conditions left-to-right and short-circuits, so cheap checks first saves CPU."
        ),
    },
    {
        "category": "yara_malware",
        "user": "Write a YARA rule to detect Cobalt Strike beacons.",
        "assistant": (
            "```yara\n"
            "import \"pe\"\n"
            "import \"math\"\n\n"
            "rule CobaltStrike_Beacon {\n"
            "    meta:\n"
            "        description = \"Detects Cobalt Strike beacon DLL/EXE by config watermark and characteristic strings\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://attack.mitre.org/software/S0154/\"\n"
            "        hash1       = \"daf3f40aa2ef7fb7a2e3e2ea20f3c81c\"\n"
            "\n"
            "    strings:\n"
            "        // CS beacon config watermarks (XOR'd with 0x69 in default profile)\n"
            "        $cs_config = { 00 01 00 01 00 02 }  // default beacon config header\n\n"
            "        // Named pipe patterns in CS DLL\n"
            "        $pipe1 = \"\\\\\\\\.\\\\pipe\\\\MSSE-\" nocase\n"
            "        $pipe2 = \"\\\\\\\\.\\\\pipe\\\\msagent_\" nocase\n"
            "        $pipe3 = \"\\\\\\\\.\\\\pipe\\\\postex\" nocase\n\n"
            "        // Malleable C2 / sleep mask artifacts\n"
            "        $sleep1 = \"sleep_mask\"\n"
            "        $sleep2 = { 48 83 EC ?? 48 89 5C 24 ?? 48 89 6C 24 }  // sleep mask stub\n\n"
            "        // CS beacon characteristic strings\n"
            "        $str1 = \"%s as %s\\\\%s: %d\"\n"
            "        $str2 = \"Started service %s on %s\"\n"
            "        $str3 = \"Running as a service (process: %d)\"\n"
            "        $str4 = \"/submit.php\"\n"
            "        $str5 = \"Content-Type: application/octet-stream\"\n\n"
            "        // High entropy section (encrypted payload)\n"
            "\n"
            "    condition:\n"
            "        (\n"
            "            // EXE/DLL\n"
            "            uint16(0) == 0x5A4D and\n"
            "            filesize < 2MB and\n"
            "            (\n"
            "                2 of ($pipe*) or\n"
            "                (1 of ($pipe*) and 1 of ($str*)) or\n"
            "                ($cs_config and 1 of ($str*)) or\n"
            "                3 of ($str*)\n"
            "            )\n"
            "        ) or\n"
            "        (\n"
            "            // Shellcode / position-independent beacon\n"
            "            filesize < 500KB and\n"
            "            $cs_config and\n"
            "            math.entropy(0, filesize) > 6.0\n"
            "        )\n"
            "}\n\n"
            "rule CobaltStrike_SleepMask {\n"
            "    meta:\n"
            "        description = \"Detects Cobalt Strike sleep mask (CS 4.5+) used for in-memory beacon obfuscation\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n\n"
            "    strings:\n"
            "        // Sleep mask characteristic byte sequences (CS 4.5 default)\n"
            "        $sm1 = { 4C 8B 53 08 45 8B 0A 45 8B 5A 04 4D 8D 52 08 }\n"
            "        $sm2 = { 48 8B 46 08 8B 48 04 48 8B 56 10 8B 02 }\n\n"
            "    condition:\n"
            "        1 of them\n"
            "}\n"
            "```\n\n"
            "**What these detect:** Cobalt Strike beacon DLLs (default and some malleable C2 profiles), "
            "sleep-masked in-memory beacons (CS 4.5+), and shellcode loaders.\n\n"
            "**False positives:** None expected for the sleep mask rule (highly specific byte pattern). "
            "The generic beacon rule may match other C2 frameworks that copy CS behavior.\n\n"
            "**Memory scanning:** Use with Volatility YARA plugin to scan running process memory:\n"
            "```bash\n"
            "vol3 -f memory.dmp windows.vadyarascan.VadYaraScan --yara-file=cs_beacon.yar\n"
            "# Or live: Process Hacker → scan process memory with YARA\n"
            "```"
        ),
    },
    {
        "category": "yara_pe",
        "user": "Write YARA rules using PE module to detect packed malware and suspicious PE characteristics.",
        "assistant": (
            "```yara\n"
            "import \"pe\"\n"
            "import \"math\"\n\n"
            "rule Suspicious_PE_Packed {\n"
            "    meta:\n"
            "        description = \"Detects likely packed PE: high entropy, few imports, small code section\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"medium\"\n\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 10MB and\n"
            "        // High entropy = encrypted/packed content\n"
            "        math.entropy(0, filesize) > 7.2 and\n"
            "        // Very few imports = stub loader\n"
            "        pe.number_of_imports < 3 and\n"
            "        // Suspicious section names (UPX, custom packers)\n"
            "        for any s in pe.sections : (\n"
            "            s.name == \"UPX0\" or\n"
            "            s.name == \"UPX1\" or\n"
            "            s.name == \".ndata\" or\n"
            "            s.name == \".themida\" or\n"
            "            s.name == \".vmp0\" or\n"
            "            (\n"
            "                // Unnamed section with high entropy = suspicious\n"
            "                s.raw_data_size > 0 and\n"
            "                math.entropy(s.raw_data_offset, s.raw_data_size) > 7.5\n"
            "            )\n"
            "        )\n"
            "}\n\n"
            "rule Suspicious_PE_NoCompiler {\n"
            "    meta:\n"
            "        description = \"PE with no recognizable Rich header — hand-assembled or obfuscated\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"low\"\n\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        not pe.rich_signature.clear_data and\n"
            "        filesize < 5MB\n"
            "}\n\n"
            "rule Suspicious_PE_SuspiciousImports {\n"
            "    meta:\n"
            "        description = \"PE importing suspicious API combinations: injection + crypto + keylogging\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 20MB and\n"
            "        // Process injection\n"
            "        pe.imports(\"kernel32.dll\", \"VirtualAllocEx\") and\n"
            "        pe.imports(\"kernel32.dll\", \"WriteProcessMemory\") and\n"
            "        pe.imports(\"kernel32.dll\", \"CreateRemoteThread\") and\n"
            "        (\n"
            "            // + Keylogging\n"
            "            pe.imports(\"user32.dll\", \"SetWindowsHookEx\") or\n"
            "            // + Screen capture\n"
            "            pe.imports(\"gdi32.dll\", \"BitBlt\") or\n"
            "            // + Crypto\n"
            "            pe.imports(\"advapi32.dll\", \"CryptEncrypt\")\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**Usage tips:**\n"
            "```bash\n"
            "# Scan directory recursively\n"
            "yara64 -r suspicious_pe.yar /path/to/samples\n\n"
            "# Scan with all three rules at once\n"
            "yara64 suspicious_pe.yar malware_sample.exe -s  # -s shows matching strings\n"
            "```\n\n"
            "**False positives:** `Suspicious_PE_Packed` will flag legitimate compressed installers. "
            "Tune entropy threshold or add an imphash whitelist for known-good packers (NSIS, Inno Setup)."
        ),
    },
    {
        "category": "yara_webshell",
        "user": "Write YARA rules to detect PHP web shells.",
        "assistant": (
            "```yara\n"
            "rule PHP_Webshell_Generic {\n"
            "    meta:\n"
            "        description = \"Detects generic PHP web shell patterns: eval+base64, system(), shell_exec() with POST input\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1505/003/\"\n\n"
            "    strings:\n"
            "        // Classic eval + base64 combo\n"
            "        $eval_b64_1 = \"eval(base64_decode(\" nocase\n"
            "        $eval_b64_2 = \"eval(gzinflate(base64_decode(\" nocase\n"
            "        $eval_b64_3 = \"eval(str_rot13(\" nocase\n"
            "        $eval_b64_4 = \"eval(gzuncompress(\" nocase\n\n"
            "        // System command execution with user input\n"
            "        $sys1 = \"system($_GET[\" nocase\n"
            "        $sys2 = \"system($_POST[\" nocase\n"
            "        $sys3 = \"system($_REQUEST[\" nocase\n"
            "        $sys4 = \"shell_exec($_\" nocase\n"
            "        $sys5 = \"passthru($_\" nocase\n"
            "        $sys6 = \"exec($_\" nocase\n"
            "        $sys7 = \"popen($_\" nocase\n\n"
            "        // Preg_replace code execution\n"
            "        $preg = /preg_replace\\s*\\(\\s*['\"]\\/.+\\/e['\"]/ nocase\n\n"
            "        // Common web shell keywords\n"
            "        $wsh1 = \"FilesMan\" nocase\n"
            "        $wsh2 = \"c99shell\" nocase\n"
            "        $wsh3 = \"r57shell\" nocase\n"
            "        $wsh4 = \"b374k\" nocase\n"
            "        $wsh5 = \"wso shell\" nocase\n"
            "        $wsh6 = \"WSO\" nocase\n\n"
            "        // PHP tags (file is PHP)\n"
            "        $php_open = \"<?php\" nocase\n\n"
            "    condition:\n"
            "        $php_open and filesize < 1MB and\n"
            "        (\n"
            "            1 of ($eval_b64_*) or\n"
            "            1 of ($sys*) or\n"
            "            $preg or\n"
            "            2 of ($wsh*)\n"
            "        )\n"
            "}\n\n"
            "rule PHP_Webshell_Obfuscated {\n"
            "    meta:\n"
            "        description = \"Detects heavily obfuscated PHP web shells using variable function calls\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n\n"
            "    strings:\n"
            "        $php_open = \"<?php\" nocase\n"
            "        // Variable functions with chr() encoding\n"
            "        $chr1 = /\\$[a-z_]+\\s*=\\s*chr\\(\\d+\\)\\s*\\.\\s*chr\\(/ nocase\n"
            "        // Long hex-encoded string assignment\n"
            "        $hex = /\\$[a-z_]+\\s*=\\s*[\"'][0-9a-f]{100,}[\"']/ nocase\n"
            "        // assert with variable\n"
            "        $assert = /assert\\s*\\(\\s*\\$/ nocase\n\n"
            "    condition:\n"
            "        $php_open and filesize < 500KB and\n"
            "        2 of ($chr1, $hex, $assert)\n"
            "}\n"
            "```\n\n"
            "**False positives:**\n"
            "- `PHP_Webshell_Generic`: Legitimate code using `eval` for template engines (rare but possible). "
            "Review context — production code rarely uses `system($_POST`.\n"
            "- `PHP_Webshell_Obfuscated`: Some obfuscated/licensed PHP software. "
            "Whitelist known-good file hashes.\n\n"
            "**Scanning web server:**\n"
            "```bash\n"
            "# Scan all PHP files in webroot\n"
            "find /var/www/html -name '*.php' | xargs yara64 webshell.yar\n"
            "# Or recursively:\n"
            "yara64 -r webshell.yar /var/www/html/\n"
            "```"
        ),
    },
    {
        "category": "yara_stealer",
        "user": "Write a YARA rule to detect information stealers targeting browser credentials.",
        "assistant": (
            "```yara\n"
            "rule InfoStealer_Browser_Credentials {\n"
            "    meta:\n"
            "        description = \"Detects information stealers targeting browser credential stores (Chrome, Firefox, Edge)\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1555/003/\"\n\n"
            "    strings:\n"
            "        // Chrome credential paths\n"
            "        $chrome1 = \"Login Data\" nocase\n"
            "        $chrome2 = \"Google\\\\Chrome\\\\User Data\" nocase\n"
            "        $chrome3 = \"Chromium\\\\User Data\" nocase\n"
            "        $chrome4 = \"Microsoft\\\\Edge\\\\User Data\" nocase\n"
            "        $chrome5 = \"Brave-Browser\\\\User Data\" nocase\n\n"
            "        // Firefox credential paths\n"
            "        $ff1 = \"logins.json\" nocase\n"
            "        $ff2 = \"key4.db\" nocase\n"
            "        $ff3 = \"Mozilla\\\\Firefox\\\\Profiles\" nocase\n\n"
            "        // Crypto wallet paths\n"
            "        $wallet1 = \"Ethereum\\\\keystore\" nocase\n"
            "        $wallet2 = \"Exodus\\\\exodus.wallet\" nocase\n"
            "        $wallet3 = \"Electrum\\\\wallets\" nocase\n"
            "        $wallet4 = \".metamask\" nocase\n\n"
            "        // Windows DPAPI (used to decrypt Chrome passwords)\n"
            "        $dpapi1 = \"CryptUnprotectData\" fullword\n"
            "        $dpapi2 = \"v10\" nocase  // Chrome v80+ encryption prefix\n\n"
            "        // SQLite access (credential databases)\n"
            "        $sqlite1 = \"SQLite format 3\" nocase\n"
            "        $sqlite2 = \"sqlite3_open\" fullword\n\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 10MB and\n"
            "        (\n"
            "            // Browser + DPAPI = strong stealer signal\n"
            "            (2 of ($chrome*) and $dpapi1) or\n"
            "            // Firefox + wallet\n"
            "            (1 of ($ff*) and 1 of ($wallet*)) or\n"
            "            // Multi-browser targeting\n"
            "            (1 of ($chrome*) and 1 of ($ff*) and 1 of ($wallet*))\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**What this detects:** Common stealer families including Vidar, Raccoon, RedLine, "
            "AZORult, META Stealer — all target Chrome/Firefox Login Data SQLite databases "
            "and use Windows DPAPI to decrypt stored passwords.\n\n"
            "**False positives:** Password managers or backup software that legitimately reads browser "
            "credential stores. Check file signature and path context.\n\n"
            "**Behavioral complement:** Monitor for access to `Login Data` files via Windows "
            "`DeviceFileEvents` in Defender for Endpoint — legitimate browsers don't copy this file."
        ),
    },
]


def generate():
    samples = []
    for item in KB:
        samples.append({
            "messages": [
                {"role": "system",    "content": HANCOCK_SYSTEM},
                {"role": "user",      "content": item["user"]},
                {"role": "assistant", "content": item["assistant"]},
            ]
        })
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT_FILE, "w") as f:
        json.dump(samples, f, indent=2)
    print(f"[yara_kb] ✅ {len(samples)} samples → {OUTPUT_FILE}")
    return samples


if __name__ == "__main__":
    generate()

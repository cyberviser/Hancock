"""
YARA Rule Knowledge Base — Hancock CyberViser
Q&A pairs for YARA rule authoring and malware detection engineering.
Outputs: data/raw_yara_kb.json
"""
import json
from pathlib import Path

OUTPUT_FILE = Path(__file__).parent.parent / "data" / "raw_yara_kb.json"

HANCOCK_SYSTEM = (
    "You are Hancock YARA, CyberViser's expert malware analyst and detection engineer. "
    "Your expertise covers YARA rule syntax (meta, strings, conditions), malware families, "
    "file-format artefacts, memory scanning, and YARA modules (pe, elf, math, hash). "
    "You always output complete, syntactically valid YARA rules with proper meta, "
    "multiple string conditions to reduce false positives, and a clear explanation. "
    "Every rule you write is ready to run with 'yara64 -r rule.yar /path'."
)

KB = [
    # ── YARA BASICS ──────────────────────────────────────────────────────────────
    {
        "category": "yara_basics",
        "user": "Explain YARA rule structure with all syntax elements and a complete example.",
        "assistant": (
            "**YARA Rule Structure — Complete Reference**\n\n"
            "```yara\n"
            "rule RuleName : tag1 tag2 {\n"
            "    meta:\n"
            "        description = \"What this rule detects\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        version     = \"1.0\"\n"
            "        hash        = \"sha256_of_sample_if_known\"\n"
            "        reference   = \"https://example.com/malware-report\"\n"
            "        severity    = \"high\"\n"
            "        tlp         = \"white\"\n"
            "\n"
            "    strings:\n"
            "        // Hex patterns (byte sequences)\n"
            "        $hex1 = { 4D 5A 90 00 03 }       // PE magic bytes (MZ)\n"
            "        $hex2 = { 48 65 6C 6C 6F }        // 'Hello' in hex\n"
            "        $hex3 = { 48 [2] 6C 6C 6F }       // with 2-byte wildcard\n"
            "        $hex4 = { 48 ?? 6C 6C 6F }        // with 1-byte wildcard\n"
            "\n"
            "        // ASCII strings\n"
            "        $str1 = \"malware.exe\"\n"
            "        $str2 = \"C:\\\\Windows\\\\Temp\\\\\" nocase\n"
            "        $str3 = \"http://c2server.\" nocase wide  // wide = UTF-16LE\n"
            "        $str4 = /https?:\\/\\/[a-z0-9]{8,12}\\.tk/  // regex\n"
            "\n"
            "        // String modifiers: nocase, wide, ascii, fullword, base64, xor\n"
            "        $str5 = \"CreateRemoteThread\" fullword\n"
            "        $str6 = \"payload\" base64 base64wide\n"
            "        $str7 = \"VirtualAlloc\" xor(1-255)  // detect XOR-obfuscated\n"
            "\n"
            "    condition:\n"
            "        // Operators: and, or, not, for, all of, any of, X of\n"
            "        uint16(0) == 0x5A4D and         // PE file check\n"
            "        filesize < 5MB and\n"
            "        (\n"
            "            2 of ($str*) or\n"
            "            all of ($hex*)\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**Key Condition Functions**\n"
            "| Function | Example | Purpose |\n"
            "|----------|---------|----------|\n"
            "| `uint8(offset)` | `uint8(0) == 0x4D` | Read 1 byte at offset |\n"
            "| `uint16(offset)` | `uint16(0) == 0x5A4D` | Read 2 bytes (little-endian) |\n"
            "| `uint32(offset)` | `uint32(0) == 0x464C457F` | ELF magic bytes |\n"
            "| `filesize` | `filesize < 1MB` | File size comparison |\n"
            "| `pe.imphash()` | `pe.imphash() == \"abc123\"` | Import hash match |\n"
            "| `pe.sections[0].name` | `pe.sections[0].name == \".text\"` | Section check |\n"
            "| `pe.imports(\"kernel32.dll\", \"VirtualAlloc\")` | API import check |\n"
            "| `math.entropy(0, filesize)` | `math.entropy(0, filesize) > 7.5` | Packed/encrypted content |\n"
            "| `#str1 > 5` | occurrence count | String appears 5+ times |\n"
            "| `@str1[0]` | first offset | Offset of first match |\n"
        ),
    },
    {
        "category": "yara_malware",
        "user": "Write a YARA rule to detect Mimikatz credential dumping tool.",
        "assistant": (
            "```yara\n"
            "rule Mimikatz_Credential_Dumper {\n"
            "    meta:\n"
            "        description = \"Detects Mimikatz credential dumping tool and its variants\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://attack.mitre.org/software/S0002/\"\n"
            "        hash        = \"fc525c9683e8fe067095ba2ddc971889\"\n"
            "\n"
            "    strings:\n"
            "        // Core Mimikatz strings\n"
            "        $mz = { 4D 5A }  // PE header\n"
            "        $s1 = \"mimikatz\" nocase\n"
            "        $s2 = \"mimilib\" nocase\n"
            "        $s3 = \"Benjamin Delpy\" nocase\n"
            "        $s4 = \"gentilkiwi\" nocase\n"
            "        $s5 = \"sekurlsa::\" nocase\n"
            "        $s6 = \"lsadump::\" nocase\n"
            "        $s7 = \"kerberos::\" nocase\n"
            "        $s8 = \"privilege::debug\" nocase\n"
            "        $s9 = \"Pass-the-Hash\" nocase\n"
            "\n"
            "        // API imports common in Mimikatz\n"
            "        $api1 = \"LsaUnprotectMemory\" fullword\n"
            "        $api2 = \"MiniDumpWriteDump\" fullword\n"
            "        $api3 = \"NtlmSharedPasswordRequest\" fullword\n"
            "\n"
            "        // Obfuscated/packed variants — hex pattern in sekurlsa module\n"
            "        $hex1 = { 6D 73 76 31 5F 30 }  // 'msv1_0'\n"
            "        $hex2 = { 6C 73 61 73 72 76 2E 64 6C 6C }  // 'lsasrv.dll'\n"
            "\n"
            "    condition:\n"
            "        $mz at 0 and\n"
            "        filesize < 10MB and\n"
            "        (\n"
            "            3 of ($s*) or\n"
            "            (1 of ($s1, $s2, $s3, $s4) and 1 of ($api*)) or\n"
            "            (2 of ($s5, $s6, $s7, $s8) and 1 of ($hex*))\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**What this detects:** Mimikatz binary (original and common forks), including obfuscated "
            "variants that retain the core module command strings.\n\n"
            "**Known false positives:** Security research tools, LSASS diagnostic utilities. "
            "Should be near-zero in production environments.\n\n"
            "**Limitations:** Heavily obfuscated/custom Mimikatz forks may evade string-based detection. "
            "For those, use behavioral detection (process access to LSASS) rather than static YARA.\n\n"
            "**Usage:**\n"
            "```bash\n"
            "yara64 -r mimikatz.yar /path/to/scan\n"
            "# Or scan memory with volatility:\n"
            "# vol.py yarascan --yara-file=mimikatz.yar -p <PID>\n"
            "```"
        ),
    },
    {
        "category": "yara_malware",
        "user": "Write a YARA rule to detect ransomware behavior patterns.",
        "assistant": (
            "```yara\n"
            "rule Ransomware_Generic_Indicators {\n"
            "    meta:\n"
            "        description = \"Detects generic ransomware behavioral indicators: shadow copy deletion, ransom notes, encryption API usage\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1490/\"\n"
            "\n"
            "    strings:\n"
            "        // Shadow copy deletion — common ransomware evasion\n"
            "        $shadow1 = \"vssadmin delete shadows\" nocase\n"
            "        $shadow2 = \"vssadmin.exe delete\" nocase\n"
            "        $shadow3 = \"wmic shadowcopy delete\" nocase\n"
            "        $shadow4 = { 76 73 73 61 64 6D 69 6E }  // 'vssadmin' hex\n"
            "\n"
            "        // Ransom note indicators\n"
            "        $note1 = \"YOUR FILES HAVE BEEN ENCRYPTED\" nocase\n"
            "        $note2 = \"All your files\" nocase\n"
            "        $note3 = \"bitcoin\" nocase\n"
            "        $note4 = \"decrypt\" nocase\n"
            "        $note5 = \"tor browser\" nocase\n"
            "        $note6 = \"onion\" nocase\n"
            "\n"
            "        // Windows crypto API usage\n"
            "        $api1 = \"CryptEncrypt\" fullword\n"
            "        $api2 = \"CryptGenKey\" fullword\n"
            "        $api3 = \"BCryptEncrypt\" fullword\n"
            "        $api4 = \"BCryptGenerateSymmetricKey\" fullword\n"
            "\n"
            "        // File operations\n"
            "        $file1 = \".locked\" nocase\n"
            "        $file2 = \".encrypted\" nocase\n"
            "        $file3 = \"!decrypt\" nocase\n"
            "        $file4 = \"README_FILES\" nocase\n"
            "        $file5 = \"HOW_TO_DECRYPT\" nocase\n"
            "\n"
            "        // Boot recovery disable\n"
            "        $boot1 = \"bcdedit /set {default} recoveryenabled No\" nocase\n"
            "        $boot2 = \"bcdedit /set {default} bootstatuspolicy ignoreallfailures\" nocase\n"
            "        $boot3 = \"wbadmin delete catalog\" nocase\n"
            "\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 20MB and\n"
            "        (\n"
            "            2 of ($shadow*) or\n"
            "            (1 of ($shadow*) and 1 of ($note*)) or\n"
            "            (2 of ($note*) and 1 of ($api*)) or\n"
            "            (1 of ($boot*) and 1 of ($api*)) or\n"
            "            (3 of ($note*, $file*))\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**What this detects:** Ransomware binaries that include shadow copy deletion commands, "
            "Windows crypto API calls, and ransom note strings — covering behavior across LockBit, "
            "REvil, Conti, BlackCat, and other common families.\n\n"
            "**False positives:** Backup software that references VSS, security awareness training materials. "
            "Rule is broad by design — tune by adjusting the condition combination thresholds.\n\n"
            "**Complement with:** Behavioral detection for high file-rename rates (MDE: DeviceFileEvents), "
            "and network rules for TOR traffic during the ransom note delivery phase."
        ),
    },
    {
        "category": "yara_malware",
        "user": "Write a YARA rule to detect a remote access trojan (RAT) dropper.",
        "assistant": (
            "```yara\n"
            "rule RAT_Dropper_Generic {\n"
            "    meta:\n"
            "        description = \"Detects generic RAT dropper characteristics: embedded payload, anti-analysis, process injection APIs\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1055/\"\n"
            "\n"
            "    strings:\n"
            "        // Process injection APIs\n"
            "        $inj1 = \"VirtualAllocEx\" fullword\n"
            "        $inj2 = \"WriteProcessMemory\" fullword\n"
            "        $inj3 = \"CreateRemoteThread\" fullword\n"
            "        $inj4 = \"NtCreateThreadEx\" fullword\n"
            "        $inj5 = \"QueueUserAPC\" fullword\n"
            "        $inj6 = \"ZwUnmapViewOfSection\" fullword\n"
            "\n"
            "        // Anti-analysis\n"
            "        $anti1 = \"IsDebuggerPresent\" fullword\n"
            "        $anti2 = \"CheckRemoteDebuggerPresent\" fullword\n"
            "        $anti3 = \"NtQueryInformationProcess\" fullword\n"
            "        $anti4 = \"GetTickCount\" fullword\n"
            "\n"
            "        // Persistence mechanisms\n"
            "        $persist1 = \"\\\\CurrentVersion\\\\Run\" nocase\n"
            "        $persist2 = \"\\\\CurrentVersion\\\\RunOnce\" nocase\n"
            "        $persist3 = \"schtasks /create\" nocase\n"
            "\n"
            "        // Network indicators\n"
            "        $net1 = \"Mozilla/\" nocase\n"
            "        $net2 = \"WinHttpConnect\" fullword\n"
            "        $net3 = \"InternetOpenUrl\" fullword\n"
            "        $net4 = \"URLDownloadToFile\" fullword\n"
            "\n"
            "        // Embedded payload markers\n"
            "        $pe_magic = { 4D 5A }  // MZ\n"
            "        $elf_magic = { 7F 45 4C 46 }  // ELF\n"
            "        $enc_pe = { 4E 5B }  // XOR-1 encoded MZ\n"
            "\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 15MB and\n"
            "        (\n"
            "            // Process injection + anti-analysis = strong dropper signal\n"
            "            (2 of ($inj*) and 1 of ($anti*)) or\n"
            "            // Injection + persistence + network\n"
            "            (2 of ($inj*) and 1 of ($persist*) and 1 of ($net*)) or\n"
            "            // Embedded PE + injection capability\n"
            "            ($pe_magic in (1024..filesize) and 2 of ($inj*))\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**What this detects:** Dropper executables that combine process injection APIs with "
            "anti-debugging, persistence, and C2 network calls — patterns consistent with RATs like "
            "AsyncRAT, njRAT, Quasar, AgentTesla, Remcos, and custom droppers.\n\n"
            "**False positives:** Legitimate software using `CreateRemoteThread` (some DLL injectors, "
            "game overlays, AV hooks). Reduce FPs by requiring 3+ conditions.\n\n"
            "**Performance tip:** Place `uint16(0) == 0x5A4D` and `filesize < 15MB` first — "
            "YARA evaluates conditions left-to-right and short-circuits, so cheap checks first saves CPU."
        ),
    },
    {
        "category": "yara_malware",
        "user": "Write a YARA rule to detect Cobalt Strike beacons.",
        "assistant": (
            "```yara\n"
            "import \"pe\"\n"
            "import \"math\"\n\n"
            "rule CobaltStrike_Beacon {\n"
            "    meta:\n"
            "        description = \"Detects Cobalt Strike beacon DLL/EXE by config watermark and characteristic strings\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://attack.mitre.org/software/S0154/\"\n"
            "        hash1       = \"daf3f40aa2ef7fb7a2e3e2ea20f3c81c\"\n"
            "\n"
            "    strings:\n"
            "        // CS beacon config watermarks (XOR'd with 0x69 in default profile)\n"
            "        $cs_config = { 00 01 00 01 00 02 }  // default beacon config header\n\n"
            "        // Named pipe patterns in CS DLL\n"
            "        $pipe1 = \"\\\\\\\\.\\\\pipe\\\\MSSE-\" nocase\n"
            "        $pipe2 = \"\\\\\\\\.\\\\pipe\\\\msagent_\" nocase\n"
            "        $pipe3 = \"\\\\\\\\.\\\\pipe\\\\postex\" nocase\n\n"
            "        // Malleable C2 / sleep mask artifacts\n"
            "        $sleep1 = \"sleep_mask\"\n"
            "        $sleep2 = { 48 83 EC ?? 48 89 5C 24 ?? 48 89 6C 24 }  // sleep mask stub\n\n"
            "        // CS beacon characteristic strings\n"
            "        $str1 = \"%s as %s\\\\%s: %d\"\n"
            "        $str2 = \"Started service %s on %s\"\n"
            "        $str3 = \"Running as a service (process: %d)\"\n"
            "        $str4 = \"/submit.php\"\n"
            "        $str5 = \"Content-Type: application/octet-stream\"\n\n"
            "        // High entropy section (encrypted payload)\n"
            "\n"
            "    condition:\n"
            "        (\n"
            "            // EXE/DLL\n"
            "            uint16(0) == 0x5A4D and\n"
            "            filesize < 2MB and\n"
            "            (\n"
            "                2 of ($pipe*) or\n"
            "                (1 of ($pipe*) and 1 of ($str*)) or\n"
            "                ($cs_config and 1 of ($str*)) or\n"
            "                3 of ($str*)\n"
            "            )\n"
            "        ) or\n"
            "        (\n"
            "            // Shellcode / position-independent beacon\n"
            "            filesize < 500KB and\n"
            "            $cs_config and\n"
            "            math.entropy(0, filesize) > 6.0\n"
            "        )\n"
            "}\n\n"
            "rule CobaltStrike_SleepMask {\n"
            "    meta:\n"
            "        description = \"Detects Cobalt Strike sleep mask (CS 4.5+) used for in-memory beacon obfuscation\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n\n"
            "    strings:\n"
            "        // Sleep mask characteristic byte sequences (CS 4.5 default)\n"
            "        $sm1 = { 4C 8B 53 08 45 8B 0A 45 8B 5A 04 4D 8D 52 08 }\n"
            "        $sm2 = { 48 8B 46 08 8B 48 04 48 8B 56 10 8B 02 }\n\n"
            "    condition:\n"
            "        1 of them\n"
            "}\n"
            "```\n\n"
            "**What these detect:** Cobalt Strike beacon DLLs (default and some malleable C2 profiles), "
            "sleep-masked in-memory beacons (CS 4.5+), and shellcode loaders.\n\n"
            "**False positives:** None expected for the sleep mask rule (highly specific byte pattern). "
            "The generic beacon rule may match other C2 frameworks that copy CS behavior.\n\n"
            "**Memory scanning:** Use with Volatility YARA plugin to scan running process memory:\n"
            "```bash\n"
            "vol3 -f memory.dmp windows.vadyarascan.VadYaraScan --yara-file=cs_beacon.yar\n"
            "# Or live: Process Hacker → scan process memory with YARA\n"
            "```"
        ),
    },
    {
        "category": "yara_pe",
        "user": "Write YARA rules using PE module to detect packed malware and suspicious PE characteristics.",
        "assistant": (
            "```yara\n"
            "import \"pe\"\n"
            "import \"math\"\n\n"
            "rule Suspicious_PE_Packed {\n"
            "    meta:\n"
            "        description = \"Detects likely packed PE: high entropy, few imports, small code section\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"medium\"\n\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 10MB and\n"
            "        // High entropy = encrypted/packed content\n"
            "        math.entropy(0, filesize) > 7.2 and\n"
            "        // Very few imports = stub loader\n"
            "        pe.number_of_imports < 3 and\n"
            "        // Suspicious section names (UPX, custom packers)\n"
            "        for any s in pe.sections : (\n"
            "            s.name == \"UPX0\" or\n"
            "            s.name == \"UPX1\" or\n"
            "            s.name == \".ndata\" or\n"
            "            s.name == \".themida\" or\n"
            "            s.name == \".vmp0\" or\n"
            "            (\n"
            "                // Unnamed section with high entropy = suspicious\n"
            "                s.raw_data_size > 0 and\n"
            "                math.entropy(s.raw_data_offset, s.raw_data_size) > 7.5\n"
            "            )\n"
            "        )\n"
            "}\n\n"
            "rule Suspicious_PE_NoCompiler {\n"
            "    meta:\n"
            "        description = \"PE with no recognizable Rich header — hand-assembled or obfuscated\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"low\"\n\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        not pe.rich_signature.clear_data and\n"
            "        filesize < 5MB\n"
            "}\n\n"
            "rule Suspicious_PE_SuspiciousImports {\n"
            "    meta:\n"
            "        description = \"PE importing suspicious API combinations: injection + crypto + keylogging\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 20MB and\n"
            "        // Process injection\n"
            "        pe.imports(\"kernel32.dll\", \"VirtualAllocEx\") and\n"
            "        pe.imports(\"kernel32.dll\", \"WriteProcessMemory\") and\n"
            "        pe.imports(\"kernel32.dll\", \"CreateRemoteThread\") and\n"
            "        (\n"
            "            // + Keylogging\n"
            "            pe.imports(\"user32.dll\", \"SetWindowsHookEx\") or\n"
            "            // + Screen capture\n"
            "            pe.imports(\"gdi32.dll\", \"BitBlt\") or\n"
            "            // + Crypto\n"
            "            pe.imports(\"advapi32.dll\", \"CryptEncrypt\")\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**Usage tips:**\n"
            "```bash\n"
            "# Scan directory recursively\n"
            "yara64 -r suspicious_pe.yar /path/to/samples\n\n"
            "# Scan with all three rules at once\n"
            "yara64 suspicious_pe.yar malware_sample.exe -s  # -s shows matching strings\n"
            "```\n\n"
            "**False positives:** `Suspicious_PE_Packed` will flag legitimate compressed installers. "
            "Tune entropy threshold or add an imphash whitelist for known-good packers (NSIS, Inno Setup)."
        ),
    },
    {
        "category": "yara_webshell",
        "user": "Write YARA rules to detect PHP web shells.",
        "assistant": (
            "```yara\n"
            "rule PHP_Webshell_Generic {\n"
            "    meta:\n"
            "        description = \"Detects generic PHP web shell patterns: eval+base64, system(), shell_exec() with POST input\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1505/003/\"\n\n"
            "    strings:\n"
            "        // Classic eval + base64 combo\n"
            "        $eval_b64_1 = \"eval(base64_decode(\" nocase\n"
            "        $eval_b64_2 = \"eval(gzinflate(base64_decode(\" nocase\n"
            "        $eval_b64_3 = \"eval(str_rot13(\" nocase\n"
            "        $eval_b64_4 = \"eval(gzuncompress(\" nocase\n\n"
            "        // System command execution with user input\n"
            "        $sys1 = \"system($_GET[\" nocase\n"
            "        $sys2 = \"system($_POST[\" nocase\n"
            "        $sys3 = \"system($_REQUEST[\" nocase\n"
            "        $sys4 = \"shell_exec($_\" nocase\n"
            "        $sys5 = \"passthru($_\" nocase\n"
            "        $sys6 = \"exec($_\" nocase\n"
            "        $sys7 = \"popen($_\" nocase\n\n"
            "        // Preg_replace code execution\n"
            "        $preg = /preg_replace\\s*\\(\\s*['\"]\\/.+\\/e['\"]/ nocase\n\n"
            "        // Common web shell keywords\n"
            "        $wsh1 = \"FilesMan\" nocase\n"
            "        $wsh2 = \"c99shell\" nocase\n"
            "        $wsh3 = \"r57shell\" nocase\n"
            "        $wsh4 = \"b374k\" nocase\n"
            "        $wsh5 = \"wso shell\" nocase\n"
            "        $wsh6 = \"WSO\" nocase\n\n"
            "        // PHP tags (file is PHP)\n"
            "        $php_open = \"<?php\" nocase\n\n"
            "    condition:\n"
            "        $php_open and filesize < 1MB and\n"
            "        (\n"
            "            1 of ($eval_b64_*) or\n"
            "            1 of ($sys*) or\n"
            "            $preg or\n"
            "            2 of ($wsh*)\n"
            "        )\n"
            "}\n\n"
            "rule PHP_Webshell_Obfuscated {\n"
            "    meta:\n"
            "        description = \"Detects heavily obfuscated PHP web shells using variable function calls\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n\n"
            "    strings:\n"
            "        $php_open = \"<?php\" nocase\n"
            "        // Variable functions with chr() encoding\n"
            "        $chr1 = /\\$[a-z_]+\\s*=\\s*chr\\(\\d+\\)\\s*\\.\\s*chr\\(/ nocase\n"
            "        // Long hex-encoded string assignment\n"
            "        $hex = /\\$[a-z_]+\\s*=\\s*[\"'][0-9a-f]{100,}[\"']/ nocase\n"
            "        // assert with variable\n"
            "        $assert = /assert\\s*\\(\\s*\\$/ nocase\n\n"
            "    condition:\n"
            "        $php_open and filesize < 500KB and\n"
            "        2 of ($chr1, $hex, $assert)\n"
            "}\n"
            "```\n\n"
            "**False positives:**\n"
            "- `PHP_Webshell_Generic`: Legitimate code using `eval` for template engines (rare but possible). "
            "Review context — production code rarely uses `system($_POST`.\n"
            "- `PHP_Webshell_Obfuscated`: Some obfuscated/licensed PHP software. "
            "Whitelist known-good file hashes.\n\n"
            "**Scanning web server:**\n"
            "```bash\n"
            "# Scan all PHP files in webroot\n"
            "find /var/www/html -name '*.php' | xargs yara64 webshell.yar\n"
            "# Or recursively:\n"
            "yara64 -r webshell.yar /var/www/html/\n"
            "```"
        ),
    },
    {
        "category": "yara_stealer",
        "user": "Write a YARA rule to detect information stealers targeting browser credentials.",
        "assistant": (
            "```yara\n"
            "rule InfoStealer_Browser_Credentials {\n"
            "    meta:\n"
            "        description = \"Detects information stealers targeting browser credential stores (Chrome, Firefox, Edge)\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1555/003/\"\n\n"
            "    strings:\n"
            "        // Chrome credential paths\n"
            "        $chrome1 = \"Login Data\" nocase\n"
            "        $chrome2 = \"Google\\\\Chrome\\\\User Data\" nocase\n"
            "        $chrome3 = \"Chromium\\\\User Data\" nocase\n"
            "        $chrome4 = \"Microsoft\\\\Edge\\\\User Data\" nocase\n"
            "        $chrome5 = \"Brave-Browser\\\\User Data\" nocase\n\n"
            "        // Firefox credential paths\n"
            "        $ff1 = \"logins.json\" nocase\n"
            "        $ff2 = \"key4.db\" nocase\n"
            "        $ff3 = \"Mozilla\\\\Firefox\\\\Profiles\" nocase\n\n"
            "        // Crypto wallet paths\n"
            "        $wallet1 = \"Ethereum\\\\keystore\" nocase\n"
            "        $wallet2 = \"Exodus\\\\exodus.wallet\" nocase\n"
            "        $wallet3 = \"Electrum\\\\wallets\" nocase\n"
            "        $wallet4 = \".metamask\" nocase\n\n"
            "        // Windows DPAPI (used to decrypt Chrome passwords)\n"
            "        $dpapi1 = \"CryptUnprotectData\" fullword\n"
            "        $dpapi2 = \"v10\" nocase  // Chrome v80+ encryption prefix\n\n"
            "        // SQLite access (credential databases)\n"
            "        $sqlite1 = \"SQLite format 3\" nocase\n"
            "        $sqlite2 = \"sqlite3_open\" fullword\n\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 10MB and\n"
            "        (\n"
            "            // Browser + DPAPI = strong stealer signal\n"
            "            (2 of ($chrome*) and $dpapi1) or\n"
            "            // Firefox + wallet\n"
            "            (1 of ($ff*) and 1 of ($wallet*)) or\n"
            "            // Multi-browser targeting\n"
            "            (1 of ($chrome*) and 1 of ($ff*) and 1 of ($wallet*))\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**What this detects:** Common stealer families including Vidar, Raccoon, RedLine, "
            "AZORult, META Stealer — all target Chrome/Firefox Login Data SQLite databases "
            "and use Windows DPAPI to decrypt stored passwords.\n\n"
            "**False positives:** Password managers or backup software that legitimately reads browser "
            "credential stores. Check file signature and path context.\n\n"
            "**Behavioral complement:** Monitor for access to `Login Data` files via Windows "
            "`DeviceFileEvents` in Defender for Endpoint — legitimate browsers don't copy this file."
        ),
    },
    {
        "category": "yara_cryptominer",
        "user": "Write YARA rules to detect cryptocurrency miners (XMRig, CoinHive) dropped on infected hosts.",
        "assistant": (
            "```yara\n"
            "rule CryptoMiner_XMRig {\n"
            "    meta:\n"
            "        description = \"Detects XMRig Monero miner binary and configuration artifacts\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1496/\"\n\n"
            "    strings:\n"
            "        $s1 = \"xmrig\" nocase fullword\n"
            "        $s2 = \"stratum+tcp://\" nocase\n"
            "        $s3 = \"stratum+ssl://\" nocase\n"
            "        $s4 = \"pool.supportxmr.com\" nocase\n"
            "        $s5 = \"donate.v2.xmrig.com\" nocase\n"
            "        $s6 = \"donate-level\" nocase\n"
            "        $s7 = \"cryptonight\" nocase\n"
            "        $s8 = \"randomx\" nocase\n"
            "        $s9 = \"hugepages\" nocase\n"
            "        $cfg1 = {22 70 6F 6F 6C 22 3A 20 7B}  // \"pool\": {\n"
            "        $cfg2 = {22 77 61 6C 6C 65 74 22 3A} // \"wallet\":\n\n"
            "    condition:\n"
            "        (uint16(0) == 0x5A4D or uint32(0) == 0x464C457F) and  // PE or ELF\n"
            "        filesize < 50MB and\n"
            "        (\n"
            "            3 of ($s*) or\n"
            "            ($s2 and $s8) or  // stratum + randomx = very likely miner\n"
            "            ($cfg1 and $cfg2 and 1 of ($s*))\n"
            "        )\n"
            "}\n\n"
            "rule CryptoMiner_Config_File {\n"
            "    meta:\n"
            "        description = \"Detects XMRig/miner JSON config files with pool + wallet\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"medium\"\n\n"
            "    strings:\n"
            "        $pool1 = \"stratum+tcp\" nocase\n"
            "        $pool2 = \"stratum+ssl\" nocase\n"
            "        $wallet = /\"user\"\\s*:\\s*\"[4|8][0-9A-Za-z]{90,105}\"/ // Monero address\n"
            "        $cpu    = \"cpu-priority\" nocase\n\n"
            "    condition:\n"
            "        filesize < 100KB and\n"
            "        1 of ($pool*) and\n"
            "        ($wallet or $cpu)\n"
            "}\n\n"
            "rule CryptoMiner_Dropper_Script {\n"
            "    meta:\n"
            "        description = \"Detects shell scripts that download and execute crypto miners\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n\n"
            "    strings:\n"
            "        $dl1 = \"curl\" nocase\n"
            "        $dl2 = \"wget\" nocase\n"
            "        $miner1 = \"xmrig\" nocase\n"
            "        $miner2 = \"minerd\" nocase\n"
            "        $miner3 = \"cpuminer\" nocase\n"
            "        $exec1 = \"chmod +x\" nocase\n"
            "        $exec2 = \"nohup\" nocase\n"
            "        $persist1 = \"crontab\" nocase\n"
            "        $persist2 = \"/etc/cron\" nocase\n\n"
            "    condition:\n"
            "        filesize < 50KB and\n"
            "        (1 of ($dl*)) and\n"
            "        (1 of ($miner*)) and\n"
            "        (1 of ($exec*) or 1 of ($persist*))\n"
            "}\n"
            "```\n\n"
            "**Detection tips:**\n"
            "- Monitor for high CPU usage (>80% sustained) via EDR\n"
            "- Alert on outbound connections to `stratum+tcp` (port 3333, 4444, 14444)\n"
            "- Check for dropped files in `/tmp`, `%TEMP%`, or masquerading as system binaries\n"
            "- XMRig often renames itself: `kworker`, `sshd`, `systemd-udevd`"
        ),
    },
    {
        "category": "yara_macro",
        "user": "Write YARA rules to detect malicious Office macro droppers.",
        "assistant": (
            "```yara\n"
            "rule Office_Malicious_Macro_Dropper {\n"
            "    meta:\n"
            "        description = \"Detects Office documents with suspicious macro patterns: download + execute, autorun\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1566/001/\"\n\n"
            "    strings:\n"
            "        // Auto-execution triggers\n"
            "        $auto1 = \"AutoOpen\" fullword nocase\n"
            "        $auto2 = \"AutoExec\" fullword nocase\n"
            "        $auto3 = \"Document_Open\" fullword nocase\n"
            "        $auto4 = \"Workbook_Open\" fullword nocase\n"
            "        $auto5 = \"Auto_Open\" fullword nocase\n\n"
            "        // Download mechanisms\n"
            "        $dl1 = \"URLDownloadToFile\" nocase\n"
            "        $dl2 = \"XMLHTTP\" nocase\n"
            "        $dl3 = \"WinHttp\" nocase\n"
            "        $dl4 = \"InternetExplorer.Application\" nocase\n"
            "        $dl5 = \"Shell.Application\" nocase\n\n"
            "        // Execution\n"
            "        $exec1 = \"WScript.Shell\" nocase\n"
            "        $exec2 = \"Shell(\" nocase\n"
            "        $exec3 = \"PowerShell\" nocase\n"
            "        $exec4 = \"cmd.exe\" nocase\n"
            "        $exec5 = \"CreateObject\" nocase\n\n"
            "        // Obfuscation indicators\n"
            "        $obf1 = \"Chr(\" nocase\n"
            "        $obf2 = \"Asc(\" nocase\n"
            "        $obf3 = \"StrReverse\" nocase\n"
            "        $obf4 = \"Join(\" nocase\n\n"
            "        // Document magic bytes (OLE)\n"
            "        $ole_magic = { D0 CF 11 E0 A1 B1 1A E1 }\n\n"
            "    condition:\n"
            "        $ole_magic at 0 and\n"
            "        filesize < 10MB and\n"
            "        (\n"
            "            // Download + execute = dropper\n"
            "            (1 of ($auto*) and 1 of ($dl*) and 1 of ($exec*)) or\n"
            "            // Heavy obfuscation + exec\n"
            "            (1 of ($auto*) and 3 of ($obf*) and 1 of ($exec*))\n"
            "        )\n"
            "}\n\n"
            "rule Office_OOXML_Macro_With_Dropper {\n"
            "    meta:\n"
            "        description = \"OOXML (.docm, .xlsm) with suspicious vbaProject.bin macro content\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"medium\"\n\n"
            "    strings:\n"
            "        $zip_magic   = { 50 4B 03 04 }  // ZIP magic (OOXML)\n"
            "        $vba_project = \"vbaProject.bin\" nocase\n"
            "        $auto        = \"AutoOpen\" nocase\n"
            "        $ps          = \"PowerShell\" nocase\n\n"
            "    condition:\n"
            "        $zip_magic at 0 and\n"
            "        $vba_project and\n"
            "        ($auto or $ps)\n"
            "}\n"
            "```\n\n"
            "**Complementary detection:**\n"
            "- Monitor for `winword.exe` spawning `powershell.exe`, `cmd.exe`, `wscript.exe` (process tree)\n"
            "- Enable ASR rule: `Block Office applications from creating child processes`\n"
            "- Disable macros via GPO for non-developer users"
        ),
    },
    {
        "category": "yara_ransomware",
        "user": "Write a YARA rule to detect ransomware file encryption behavior by looking for ransom note strings.",
        "assistant": (
            "```yara\n"
            "rule Ransomware_Generic_Note {\n"
            "    meta:\n"
            "        description = \"Detects generic ransomware ransom note patterns across major families\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1486/\"\n\n"
            "    strings:\n"
            "        // Common ransom note phrases (case-insensitive)\n"
            "        $note1  = \"your files have been encrypted\" nocase\n"
            "        $note2  = \"all your files are encrypted\" nocase\n"
            "        $note3  = \"your data has been encrypted\" nocase\n"
            "        $note4  = \"YOUR FILES ARE ENCRYPTED\" nocase\n"
            "        $note5  = \"to decrypt your files\" nocase\n"
            "        $note6  = \"to recover your files\" nocase\n"
            "        $note7  = \"to restore your files\" nocase\n\n"
            "        // Bitcoin / crypto payment\n"
            "        $pay1 = \"bitcoin\" nocase\n"
            "        $pay2 = \"BTC\" nocase\n"
            "        $pay3 = \"monero\" nocase\n"
            "        $pay4 = \"cryptocurrency\" nocase\n"
            "        $pay5 = \"wallet\" nocase\n\n"
            "        // Contact / tor info\n"
            "        $contact1 = \".onion\" nocase\n"
            "        $contact2 = \"tor browser\" nocase\n"
            "        $contact3 = \"decryption key\" nocase\n"
            "        $contact4 = \"unique ID\" nocase\n\n"
            "        // Known family-specific strings\n"
            "        $fam_lockbit  = \"LockBit\" nocase\n"
            "        $fam_conti    = \"CONTI\" nocase\n"
            "        $fam_ryuk     = \"RyukReadMe\" nocase\n"
            "        $fam_clop     = \"CLOP^_\" nocase\n"
            "        $fam_revil    = \"sodinokibi\" nocase\n"
            "        $fam_blackcat = \"ALPHV\" nocase\n"
            "        $fam_akira    = \"akira\" nocase\n\n"
            "    condition:\n"
            "        filesize < 500KB and\n"
            "        (\n"
            "            // Known ransomware family name\n"
            "            1 of ($fam_*) or\n"
            "            // Generic: note phrase + payment method\n"
            "            (1 of ($note*) and 1 of ($pay*)) or\n"
            "            // Note + tor contact\n"
            "            (1 of ($note*) and 1 of ($contact*))\n"
            "        )\n"
            "}\n\n"
            "rule Ransomware_File_Enumerator {\n"
            "    meta:\n"
            "        description = \"PE binary enumerating files for encryption: FindFirstFile + CryptEncrypt pattern\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n\n"
            "    strings:\n"
            "        $api1 = \"FindFirstFileW\" fullword\n"
            "        $api2 = \"FindNextFileW\" fullword\n"
            "        $api3 = \"CryptEncrypt\" fullword\n"
            "        $api4 = \"BCryptEncrypt\" fullword\n"
            "        $api5 = \"DeleteFile\" fullword\n"
            "        $ext1 = \".encrypted\" nocase\n"
            "        $ext2 = \".locked\" nocase\n"
            "        $ext3 = \".enc\" nocase\n"
            "        $ext4 = \".ransom\" nocase\n\n"
            "    condition:\n"
            "        uint16(0) == 0x5A4D and\n"
            "        filesize < 10MB and\n"
            "        ($api1 and $api2) and\n"
            "        (1 of ($api3, $api4)) and\n"
            "        (1 of ($ext*) or $api5)\n"
            "}\n"
            "```\n\n"
            "**Incident response when ransomware YARA fires:**\n"
            "1. Isolate host from network IMMEDIATELY\n"
            "2. Preserve memory dump before shutdown: `winpmem_mini.exe mem.dmp`\n"
            "3. Check shadow copies: `vssadmin list shadows`\n"
            "4. Identify encryption key in memory (some families store in process)\n"
            "5. Check ID Ransomware: https://id-ransomware.malwarehunterteam.com"
        ),
    },
    {
        "category": "yara_network",
        "user": "Write a YARA rule to detect Sliver C2 framework implants (alternative to Cobalt Strike).",
        "assistant": (
            "```yara\n"
            "rule C2_Sliver_Implant {\n"
            "    meta:\n"
            "        description = \"Detects Sliver C2 framework implants (Go-based, cross-platform)\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://github.com/BishopFox/sliver\"\n\n"
            "    strings:\n"
            "        // Go module paths\n"
            "        $go1 = \"github.com/bishopfox/sliver\" nocase\n"
            "        $go2 = \"sliver/implant\" nocase\n"
            "        $go3 = \"sliver/protobuf\" nocase\n\n"
            "        // Sliver-specific function names\n"
            "        $fn1 = \"SliverMetaData\" fullword\n"
            "        $fn2 = \"sliverRPCHandler\" fullword\n"
            "        $fn3 = \"implantConfig\" fullword\n\n"
            "        // C2 protocol markers\n"
            "        $proto1 = \"MTLS\" fullword\n"
            "        $proto2 = \"WireGuard\" nocase\n"
            "        $proto3 = \"implant/pivot\" nocase\n\n"
            "        // Default mutex/naming patterns in builds\n"
            "        $name1 = /[A-Z][A-Z_]{3,}[A-Z]\\x00{1,5}[A-Z][A-Z_]{3,}[A-Z]/ // Sliver uses random codenames\n\n"
            "    condition:\n"
            "        (uint16(0) == 0x5A4D or uint32(0) == 0x464C457F) and\n"
            "        filesize < 50MB and\n"
            "        (\n"
            "            2 of ($go*) or\n"
            "            (1 of ($go*) and 1 of ($fn*)) or\n"
            "            (1 of ($fn*) and 1 of ($proto*))\n"
            "        )\n"
            "}\n\n"
            "rule C2_Havoc_Framework {\n"
            "    meta:\n"
            "        description = \"Detects Havoc C2 framework demon agents\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n"
            "        reference   = \"https://github.com/HavocFramework/Havoc\"\n\n"
            "    strings:\n"
            "        $s1 = \"HavocAgent\" nocase\n"
            "        $s2 = \"demon.x64.exe\" nocase\n"
            "        $s3 = \"HavocC2\" nocase\n"
            "        $s4 = \"DEMON_MAGIC\" nocase\n"
            "        $s5 = \"Demons\" fullword nocase\n\n"
            "    condition:\n"
            "        (uint16(0) == 0x5A4D) and\n"
            "        filesize < 10MB and\n"
            "        2 of them\n"
            "}\n"
            "```\n\n"
            "**Emerging C2 framework signatures to track:**\n"
            "- **Brute Ratel C4** — look for `badger` strings, BRC4 watermark\n"
            "- **Mythic** — Python/Go agents, HTTP beacon with UUID in path\n"
            "- **Nighthawk** — commercial, encrypted comms, minimal IOCs (use behavioral detection)\n\n"
            "These frameworks are used by both red teams (authorized) and threat actors. "
            "Correlate with context: authorized pentest window, unusual process parent, "
            "network connections to non-corporate IPs."
        ),
    },
    {
        "category": "yara_pdf",
        "user": "Write YARA rules to detect malicious PDF files with JavaScript exploits or embedded executables.",
        "assistant": (
            "```yara\n"
            "rule PDF_Malicious_JavaScript {\n"
            "    meta:\n"
            "        description = \"Detects PDFs with embedded JavaScript that uses suspicious functions\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1204/002/\"\n\n"
            "    strings:\n"
            "        $magic  = { 25 50 44 46 }  // %PDF\n"
            "        $js1 = \"/JavaScript\" nocase\n"
            "        $js2 = \"/JS\" nocase\n\n"
            "        // Exploit-related JS\n"
            "        $exp1 = \"unescape\" nocase\n"
            "        $exp2 = \"eval\" nocase\n"
            "        $exp3 = \"String.fromCharCode\" nocase\n"
            "        $exp4 = \"shellcode\" nocase\n"
            "        $exp5 = \"util.printf\" nocase  // CVE-2008-2992 (printf overflow)\n"
            "        $exp6 = \"getAnnots\" nocase     // CVE-2010-0188\n"
            "        $exp7 = \"app.doc.syncAnnotScan\" nocase\n"
            "        $exp8 = \"Collab.collectEmailInfo\" nocase  // historic exploit\n\n"
            "        // Heap spray indicators\n"
            "        $heap1 = /[%u9090%u9090]{10,}/  // NOP sled in JS\n"
            "        $heap2 = /\\\\u9090\\\\u9090\\\\u9090/\n\n"
            "    condition:\n"
            "        $magic at 0 and\n"
            "        filesize < 20MB and\n"
            "        (1 of ($js*)) and\n"
            "        (\n"
            "            2 of ($exp*) or\n"
            "            1 of ($heap*)\n"
            "        )\n"
            "}\n\n"
            "rule PDF_Embedded_Executable {\n"
            "    meta:\n"
            "        description = \"Detects PDFs with embedded PE executables or ZIP archives (droppers)\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"critical\"\n\n"
            "    strings:\n"
            "        $pdf_magic  = { 25 50 44 46 }  // %PDF\n"
            "        $pe_magic   = { 4D 5A }         // MZ\n"
            "        $elf_magic  = { 7F 45 4C 46 }   // ELF\n"
            "        $zip_magic  = { 50 4B 03 04 }   // ZIP\n"
            "        $embed1 = \"/EmbeddedFile\" nocase\n"
            "        $embed2 = \"/Filespec\" nocase\n"
            "        $launch = \"/Launch\" nocase\n"
            "        $openaction = \"/OpenAction\" nocase\n\n"
            "    condition:\n"
            "        $pdf_magic at 0 and\n"
            "        filesize < 20MB and\n"
            "        ($launch or $openaction) and\n"
            "        (\n"
            "            for any i in (1..#pe_magic): (\n"
            "                @pe_magic[i] > 1024  // PE not at offset 0 = embedded\n"
            "            ) or\n"
            "            $zip_magic or\n"
            "            1 of ($embed*)\n"
            "        )\n"
            "}\n"
            "```\n\n"
            "**Analysis tools for suspicious PDFs:**\n"
            "```bash\n"
            "# Extract JavaScript from PDF\n"
            "pdfid.py malicious.pdf\n"
            "pdf-parser.py --search javascript malicious.pdf\n\n"
            "# Extract embedded files\n"
            "peepdf malicious.pdf -i  # interactive mode\n\n"
            "# Sandbox detonation\n"
            "# Submit to: any.run, hybrid-analysis.com, virustotal.com/gui/file\n"
            "```"
        ),
    },
    {
        "category": "yara_obfuscation",
        "user": "Write YARA rules to detect PowerShell obfuscation techniques used to evade detection.",
        "assistant": (
            "```yara\n"
            "rule PowerShell_Obfuscation_Invoke {\n"
            "    meta:\n"
            "        description = \"Detects heavily obfuscated PowerShell: Invoke-Obfuscation, AMSI bypass patterns\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"high\"\n"
            "        reference   = \"https://attack.mitre.org/techniques/T1027/\"\n\n"
            "    strings:\n"
            "        // Invoke-Expression variants (case-scramble obfuscation)\n"
            "        $iex1 = /[Ii][Nn][Vv][Oo][Kk][Ee]\\s*-\\s*[Ee][Xx][Pp][Rr][Ee][Ss][Ss][Ii][Oo][Nn]/ nocase\n"
            "        $iex2 = \"IEX(\" nocase\n"
            "        $iex3 = \"`I`E`X\" nocase\n"
            "        $iex4 = /i.e.x.\\(/ nocase\n\n"
            "        // Base64 encoded command\n"
            "        $enc1 = \"-EncodedCommand\" nocase\n"
            "        $enc2 = \"-enc \" nocase\n"
            "        $enc3 = \"-en \" nocase\n"
            "        $enc4 = \"-e \" nocase\n\n"
            "        // AMSI bypass patterns\n"
            "        $amsi1 = \"AmsiUtils\" nocase\n"
            "        $amsi2 = \"amsiContext\" nocase\n"
            "        $amsi3 = \"amsiInitFailed\" nocase\n"
            "        $amsi4 = \"Disable-AmsiProvider\" nocase\n"
            "        $amsi5 = \"[Runtime.InteropServices.Marshal]::Copy\" nocase\n\n"
            "        // Concatenation obfuscation: ('powe'+'rshell')\n"
            "        $concat1 = /('\\w+'\\s*\\+\\s*'\\w+'){3,}/ nocase\n"
            "        $concat2 = /\"\\w+\"\\s*\\+\\s*\"\\w+\"\\s*\\+\\s*\"\\w+\"/ nocase\n\n"
            "        // Download + execute (common dropper pattern)\n"
            "        $dl1 = \"DownloadString\" nocase\n"
            "        $dl2 = \"DownloadFile\" nocase\n"
            "        $dl3 = \"WebClient\" nocase\n\n"
            "    condition:\n"
            "        filesize < 5MB and\n"
            "        (\n"
            "            // AMSI bypass = very suspicious\n"
            "            1 of ($amsi*) or\n"
            "            // Encoded + download\n"
            "            (1 of ($enc*) and 1 of ($dl*)) or\n"
            "            // Heavy concatenation + IEX\n"
            "            (1 of ($iex*) and 1 of ($concat*)) or\n"
            "            // Multiple IEX variants\n"
            "            2 of ($iex*)\n"
            "        )\n"
            "}\n\n"
            "rule PowerShell_Encoded_Payload_Heuristic {\n"
            "    meta:\n"
            "        description = \"Heuristic: PS1 file with very high ratio of base64/special chars\"\n"
            "        author      = \"Hancock / CyberViser\"\n"
            "        date        = \"2025-01-15\"\n"
            "        severity    = \"medium\"\n\n"
            "    strings:\n"
            "        $ps1 = \".ps1\" nocase\n"
            "        $b64_block = /[A-Za-z0-9+\\/]{200,}={0,2}/  // long base64 string\n"
            "        $char1 = \"[char]\" nocase\n"
            "        $char2 = \"[byte]\" nocase\n\n"
            "    condition:\n"
            "        filesize < 1MB and\n"
            "        (($b64_block and (\"powershell\" nocase)) or\n"
            "         (#char1 + #char2) > 50)  // char obfuscation\n"
            "}\n"
            "```"
        ),
    },
    # ── ADDITIONAL RULES ─────────────────────────────────────────────────────
    {
        "user": "Write a YARA rule to detect QakBot (QBot) banking trojan samples.",
        "assistant": '```yara\nrule QakBot_Trojan {\n    meta:\n        description = "Detects QakBot banking trojan"\n        author = "Hancock CyberViser"\n        mitre_attack = "T1055, T1021.002"\n\n    strings:\n        $reg1   = "SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run" wide\n        $cmd1   = "cmd /c ping" ascii nocase\n        $inject = { 64 A1 30 00 00 00 8B 40 0C 8B 40 1C }\n        $str1   = "qbot" ascii nocase\n        $str2   = "qakbot" ascii nocase\n\n    condition:\n        uint16(0) == 0x5A4D and\n        filesize < 2MB and\n        ($reg1 or $inject) and\n        1 of ($str*)\n}\n```',
    },
    {
        "user": "Write a YARA rule to detect AsyncRAT remote access trojan.",
        "assistant": '```yara\nrule AsyncRAT {\n    meta:\n        description = "Detects AsyncRAT .NET RAT"\n        author = "Hancock CyberViser"\n        mitre_attack = "T1219"\n\n    strings:\n        $s1 = "AsyncClient" ascii wide\n        $s2 = "AsyncRAT" ascii wide\n        $s3 = "Stub.exe" ascii wide\n        $mutex = { 41 00 73 00 79 00 6E 00 63 00 52 00 41 00 54 00 }\n        $dotnet = { 4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF }\n\n    condition:\n        $dotnet at 0 and filesize < 5MB and\n        (2 of ($s*)) and $mutex\n}\n```',
    },
    {
        "user": "Write a YARA rule to detect malicious LNK shortcut files used in phishing (T1204.002).",
        "assistant": '```yara\nrule Malicious_LNK_Phishing {\n    meta:\n        description = "Detects malicious LNK files executing PowerShell or cmd"\n        author = "Hancock CyberViser"\n        mitre_attack = "T1204.002"\n\n    strings:\n        $lnk_magic = { 4C 00 00 00 01 14 02 00 }\n        $ps1 = "powershell" ascii wide nocase\n        $cmd1 = "cmd.exe" ascii wide nocase\n        $dl1 = "http://" ascii wide nocase\n        $dl2 = "https://" ascii wide nocase\n        $hidden = "-WindowStyle Hidden" ascii wide nocase\n\n    condition:\n        $lnk_magic at 0 and filesize < 5MB and\n        (1 of ($ps*, $cmd*)) and\n        (1 of ($dl*, $hidden))\n}\n```',
    },
    {
        "user": "Write a YARA rule to detect Metasploit Meterpreter shellcode.",
        "assistant": '```yara\nrule Metasploit_Meterpreter {\n    meta:\n        description = "Detects Meterpreter reverse shell shellcode"\n        author = "Hancock CyberViser"\n        mitre_attack = "T1059, T1055"\n\n    strings:\n        $met1 = { FC E8 8? 00 00 00 60 89 E5 31 D2 64 8B }\n        $met2 = { FC 48 83 E4 F0 E8 C? 00 00 00 41 51 41 50 52 51 }\n        $mets1 = "metsrv.x64.dll" ascii\n        $mets2 = "ReflectiveLoader" ascii\n        $mets3 = "Meterpreter" ascii\n\n    condition:\n        (1 of ($met*)) or (2 of ($mets*))\n}\n```',
    },
    {
        "user": "Write a YARA rule to detect generic cryptominers (XMR pools, stratum protocol, T1496).",
        "assistant": '```yara\nrule CryptoMiner_Generic {\n    meta:\n        description = "Detects cryptominer pool strings and tools"\n        author = "Hancock CyberViser"\n        mitre_attack = "T1496"\n\n    strings:\n        $pool1 = "pool.minexmr.com" ascii nocase\n        $pool2 = "supportxmr.com" ascii nocase\n        $stratum1 = "stratum+tcp://" ascii nocase\n        $stratum2 = "stratum+ssl://" ascii nocase\n        $xmrig = "XMRig" ascii\n        $arg1 = "--donate-level" ascii\n        $arg2 = "-o stratum" ascii nocase\n\n    condition:\n        filesize < 50MB and (\n            1 of ($pool*) or\n            1 of ($stratum*) or\n            ($xmrig and 1 of ($arg*))\n        )\n}\n```',
    },
    {
        "user": "Write a YARA rule to detect Golang-compiled malware (common in ransomware and C2 implants).",
        "assistant": '```yara\nrule Golang_Compiled_Malware {\n    meta:\n        description = "Detects Go-compiled executables — common in ransomware/RATs"\n        author = "Hancock CyberViser"\n        mitre_attack = "T1027"\n\n    strings:\n        $go1 = "Go build ID:" ascii\n        $go2 = "runtime.panic" ascii\n        $go3 = "runtime.throw" ascii\n        $go4 = "main.main" ascii\n        $gopath1 = "/usr/local/go/src" ascii\n        $gopath2 = "C:/Go/src" ascii\n\n    condition:\n        uint16(0) == 0x5A4D and filesize > 1MB and\n        (2 of ($go*) or $gopath1 or $gopath2)\n}\n```',
    },
    {
        "user": "What are YARA rule performance best practices to avoid slow scans on large corpora?",
        "assistant": '# YARA Rule Performance Best Practices\n\n## Performance hierarchy (fast → slow)\n```\nfilesize → uint16/magic → string matching → regex → PE/ELF modules\n```\n\n## 1. Always filter with filesize and magic first\n```yara\ncondition:\n    filesize < 5MB and           // Eliminates 90%+ of files\n    uint16(0) == 0x5A4D and      // PE magic check\n    $suspicious_string            // Expensive string match last\n```\n\n## 2. Anchor strings to specific offsets\n```yara\n$header at 0                     // Much faster than anywhere search\n$footer in (filesize-100..filesize)\n```\n\n## 3. Use \'N of ($strings*)\' over boolean chains\n```yara\n// Slower: ($a or $b or $c or $d)\n// Faster:\n1 of ($indicators*)\n3 of ($strings*)\n```\n\n## 4. Avoid regex — prefer fixed strings\n```yara\n// Slow: $r = /https?:\\/\\/[0-9.]+/\n// Better:\n$h1 = "http://"\n$h2 = "https://"\n```\n\n## 5. Use hex for binary patterns\n```yara\n$sc = { FC E8 8? 00 00 00 60 89 E5 }  // Wildcard bytes with ?\n```\n\n## 6. Minimize \'nocase\' and \'wide\' modifiers\nEach doubles scan time — use only when required.\n\n## 7. Profile your rules\n```bash\nyara --benchmark rule.yar /corpus/\n```',
    },
    {
        "user": "Write a YARA rule to detect common packers (UPX, ASPack) used to obfuscate malware (T1027.002).",
        "assistant": '```yara\nrule Packed_Executable {\n    meta:\n        description = "Detects common packers (UPX, ASPack) used to obfuscate malware"\n        author = "Hancock CyberViser"\n        mitre_attack = "T1027.002"\n\n    strings:\n        $upx0 = "UPX0" ascii\n        $upx1 = "UPX1" ascii\n        $upx2 = "UPX!" ascii\n        $aspack = "ASPack" ascii\n        $nspack = "NsPacK" ascii\n        $fsg = { 60 BE ?? ?? ?? 00 8D BE ?? ?? ?? FF 57 83 CD FF }\n\n    condition:\n        uint16(0) == 0x5A4D and filesize < 10MB and\n        (1 of ($upx*) or $aspack or $nspack or $fsg)\n}\n```',
    },
    {
        "user": "Write a YARA rule to detect malicious DLL side-loading (T1574.002).",
        "assistant": '```yara\nrule DLL_SideLoading_Artifact {\n    meta:\n        description = "Detects DLLs with side-loading indicators"\n        author = "Hancock CyberViser"\n        mitre_attack = "T1574.002"\n\n    strings:\n        $exp1 = "DllMain" ascii\n        $dl1 = "http://" ascii wide nocase\n        $dl2 = "URLDownloadToFile" ascii wide\n        $ps1 = "powershell" ascii wide nocase\n        $launch = "CreateProcess" ascii wide\n        $inject = "VirtualAllocEx" ascii wide\n\n    condition:\n        uint16(0) == 0x5A4D and\n        (uint16(uint32(0x3c) + 0x16) & 0x2000) != 0 and\n        $exp1 and\n        (1 of ($dl*, $ps*)) and\n        ($launch or $inject)\n}\n```',
    },

]


def generate():
    samples = []
    for item in KB:
        samples.append({
            "messages": [
                {"role": "system",    "content": HANCOCK_SYSTEM},
                {"role": "user",      "content": item["user"]},
                {"role": "assistant", "content": item["assistant"]},
            ]
        })
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT_FILE, "w") as f:
        json.dump(samples, f, indent=2)
    print(f"[yara_kb] ✅ {len(samples)} samples → {OUTPUT_FILE}")
    return samples


if __name__ == "__main__":
    generate()

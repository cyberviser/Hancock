"""
Security Code Knowledge Base â€” Hancock CyberViser
Q&A pairs for security code generation (Python, Bash, PowerShell, YARA, Sigma).
Outputs: data/raw_code_kb.json
"""
import json
from pathlib import Path

OUTPUT_FILE = Path(__file__).parent.parent / "data" / "raw_code_kb.json"

HANCOCK_SYSTEM = (
    "You are Hancock Code, CyberViser's expert security code assistant. "
    "You write production-quality security tooling code in Python, Bash, PowerShell, and Go. "
    "Your specialties include security automation, SIEM queries, detection scripts, "
    "pentest helpers, and secure code review. "
    "You always add authorization warnings to offensive tooling, include error handling, "
    "type hints, and docstrings, and explain security implications. "
    "You are Hancock Code. Precision over verbosity. Ship working code."
)

KB = [
    # â”€â”€ SECURITY AUTOMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {
        "category": "security_automation",
        "user": "Write a Python script to automatically enrich IOCs (IPs, domains, hashes) using VirusTotal API.",
        "assistant": (
            "```python\n"
            "#!/usr/bin/env python3\n"
            "\"\"\"\n"
            "IOC Enricher â€” Hancock CyberViser\n"
            "Enriches IPs, domains, URLs, and file hashes via VirusTotal APIv3.\n"
            "\n"
            "Usage:\n"
            "    python ioc_enricher.py --ioc 8.8.8.8 --type ip\n"
            "    python ioc_enricher.py --ioc malware.exe --type file\n"
            "    python ioc_enricher.py --file iocs.txt  # bulk processing\n"
            "\n"
            "Requirements: pip install requests python-dotenv\n"
            "Set VT_API_KEY in .env or environment.\n"
            "\"\"\"\n"
            "import argparse\n"
            "import json\n"
            "import os\n"
            "import sys\n"
            "import time\n"
            "from pathlib import Path\n"
            "from typing import Optional\n"
            "\n"
            "import requests\n\n"
            "VT_BASE = \"https://www.virustotal.com/api/v3\"\n"
            "RATE_LIMIT_DELAY = 15  # seconds between requests (free tier = 4 req/min)\n\n\n"
            "def get_vt_headers() -> dict:\n"
            "    \"\"\"Get VirusTotal API headers.\"\"\"\n"
            "    api_key = os.getenv(\"VT_API_KEY\", \"\")\n"
            "    if not api_key:\n"
            "        sys.exit(\"ERROR: Set VT_API_KEY environment variable.\")\n"
            "    return {\"x-apikey\": api_key}\n\n\n"
            "def enrich_ip(ip: str) -> dict:\n"
            "    \"\"\"Enrich an IP address via VirusTotal.\"\"\"\n"
            "    resp = requests.get(f\"{VT_BASE}/ip_addresses/{ip}\", headers=get_vt_headers(), timeout=30)\n"
            "    resp.raise_for_status()\n"
            "    data = resp.json()[\"data\"][\"attributes\"]\n"
            "    stats = data.get(\"last_analysis_stats\", {})\n"
            "    return {\n"
            "        \"ioc\": ip,\n"
            "        \"type\": \"ip\",\n"
            "        \"malicious\": stats.get(\"malicious\", 0),\n"
            "        \"suspicious\": stats.get(\"suspicious\", 0),\n"
            "        \"harmless\": stats.get(\"harmless\", 0),\n"
            "        \"country\": data.get(\"country\", \"unknown\"),\n"
            "        \"asn\": data.get(\"asn\", \"\"),\n"
            "        \"as_owner\": data.get(\"as_owner\", \"\"),\n"
            "        \"reputation\": data.get(\"reputation\", 0),\n"
            "        \"categories\": list(set(data.get(\"categories\", {}).values())),\n"
            "        \"verdict\": \"MALICIOUS\" if stats.get(\"malicious\", 0) > 5 else\n"
            "                    \"SUSPICIOUS\" if stats.get(\"malicious\", 0) > 0 else \"CLEAN\",\n"
            "    }\n\n\n"
            "def enrich_domain(domain: str) -> dict:\n"
            "    \"\"\"Enrich a domain via VirusTotal.\"\"\"\n"
            "    resp = requests.get(f\"{VT_BASE}/domains/{domain}\", headers=get_vt_headers(), timeout=30)\n"
            "    resp.raise_for_status()\n"
            "    data = resp.json()[\"data\"][\"attributes\"]\n"
            "    stats = data.get(\"last_analysis_stats\", {})\n"
            "    return {\n"
            "        \"ioc\": domain,\n"
            "        \"type\": \"domain\",\n"
            "        \"malicious\": stats.get(\"malicious\", 0),\n"
            "        \"suspicious\": stats.get(\"suspicious\", 0),\n"
            "        \"registrar\": data.get(\"registrar\", \"\"),\n"
            "        \"creation_date\": data.get(\"creation_date\", 0),\n"
            "        \"categories\": list(set(data.get(\"categories\", {}).values())),\n"
            "        \"popularity_ranks\": data.get(\"popularity_ranks\", {}),\n"
            "        \"verdict\": \"MALICIOUS\" if stats.get(\"malicious\", 0) > 5 else\n"
            "                    \"SUSPICIOUS\" if stats.get(\"malicious\", 0) > 0 else \"CLEAN\",\n"
            "    }\n\n\n"
            "def enrich_hash(file_hash: str) -> dict:\n"
            "    \"\"\"Enrich a file hash (MD5/SHA1/SHA256) via VirusTotal.\"\"\"\n"
            "    resp = requests.get(f\"{VT_BASE}/files/{file_hash}\", headers=get_vt_headers(), timeout=30)\n"
            "    if resp.status_code == 404:\n"
            "        return {\"ioc\": file_hash, \"type\": \"hash\", \"verdict\": \"NOT_FOUND\",\n"
            "                \"note\": \"Hash not in VT database â€” may be new/rare\"}\n"
            "    resp.raise_for_status()\n"
            "    data = resp.json()[\"data\"][\"attributes\"]\n"
            "    stats = data.get(\"last_analysis_stats\", {})\n"
            "    return {\n"
            "        \"ioc\": file_hash,\n"
            "        \"type\": \"hash\",\n"
            "        \"malicious\": stats.get(\"malicious\", 0),\n"
            "        \"suspicious\": stats.get(\"suspicious\", 0),\n"
            "        \"type_description\": data.get(\"type_description\", \"\"),\n"
            "        \"magic\": data.get(\"magic\", \"\"),\n"
            "        \"names\": data.get(\"names\", [])[:5],\n"
            "        \"size\": data.get(\"size\", 0),\n"
            "        \"imphash\": data.get(\"pe_info\", {}).get(\"imphash\", \"\"),\n"
            "        \"first_submission_date\": data.get(\"first_submission_date\", 0),\n"
            "        \"verdict\": \"MALICIOUS\" if stats.get(\"malicious\", 0) > 5 else\n"
            "                    \"SUSPICIOUS\" if stats.get(\"malicious\", 0) > 0 else \"CLEAN\",\n"
            "    }\n\n\n"
            "def process_ioc(ioc: str, ioc_type: Optional[str] = None) -> dict:\n"
            "    \"\"\"Auto-detect IOC type and enrich.\"\"\"\n"
            "    import re\n"
            "    if not ioc_type:\n"
            "        if re.match(r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$', ioc):\n"
            "            ioc_type = \"ip\"\n"
            "        elif re.match(r'^[0-9a-fA-F]{32,64}$', ioc):\n"
            "            ioc_type = \"hash\"\n"
            "        else:\n"
            "            ioc_type = \"domain\"\n\n"
            "    dispatch = {\"ip\": enrich_ip, \"domain\": enrich_domain, \"hash\": enrich_hash}\n"
            "    return dispatch.get(ioc_type, enrich_domain)(ioc)\n\n\n"
            "def main():\n"
            "    parser = argparse.ArgumentParser(description=\"IOC Enricher â€” Hancock CyberViser\")\n"
            "    parser.add_argument(\"--ioc\",  help=\"Single IOC to enrich\")\n"
            "    parser.add_argument(\"--type\", choices=[\"ip\", \"domain\", \"hash\", \"url\"], help=\"IOC type\")\n"
            "    parser.add_argument(\"--file\", help=\"File with one IOC per line\")\n"
            "    parser.add_argument(\"--output\", default=\"ioc_report.json\", help=\"Output file\")\n"
            "    args = parser.parse_args()\n\n"
            "    iocs = []\n"
            "    if args.ioc:\n"
            "        iocs = [(args.ioc, args.type)]\n"
            "    elif args.file:\n"
            "        iocs = [(line.strip(), None) for line in Path(args.file).read_text().splitlines() if line.strip()]\n"
            "    else:\n"
            "        parser.print_help(); sys.exit(1)\n\n"
            "    results = []\n"
            "    for i, (ioc, ioc_type) in enumerate(iocs):\n"
            "        print(f\"[{i+1}/{len(iocs)}] Enriching: {ioc} ...\", end=\" \", flush=True)\n"
            "        try:\n"
            "            result = process_ioc(ioc, ioc_type)\n"
            "            verdict = result.get(\"verdict\", \"?\")\n"
            "            malicious = result.get(\"malicious\", 0)\n"
            "            print(f\"â†’ {verdict} ({malicious} detections)\")\n"
            "            results.append(result)\n"
            "        except requests.HTTPError as e:\n"
            "            print(f\"â†’ ERROR: {e}\")\n"
            "            results.append({\"ioc\": ioc, \"error\": str(e)})\n"
            "        if i < len(iocs) - 1:\n"
            "            time.sleep(RATE_LIMIT_DELAY)  # respect free tier rate limit\n\n"
            "    Path(args.output).write_text(json.dumps(results, indent=2))\n"
            "    print(f\"\\nâœ… Report saved â†’ {args.output}\")\n"
            "    malicious_count = sum(1 for r in results if r.get(\"verdict\") == \"MALICIOUS\")\n"
            "    print(f\"   MALICIOUS: {malicious_count} / {len(results)}\")\n\n\n"
            "if __name__ == \"__main__\":\n"
            "    main()\n"
            "```\n\n"
            "**Usage:**\n"
            "```bash\n"
            "export VT_API_KEY='your_vt_key'\n"
            "python ioc_enricher.py --ioc 185.220.101.45 --type ip\n"
            "python ioc_enricher.py --file iocs.txt --output report.json\n"
            "```"
        ),
    },
    {
        "category": "security_automation",
        "user": "Write a Python script to parse Nmap XML output and generate a vulnerability report.",
        "assistant": (
            "```python\n"
            "#!/usr/bin/env python3\n"
            "\"\"\"\n"
            "Nmap XML Parser â€” Hancock CyberViser\n"
            "Parses Nmap XML scan output and generates a structured pentest report.\n"
            "\n"
            "Usage:\n"
            "    nmap -sV -sC -oX scan.xml 192.168.1.0/24\n"
            "    python nmap_parser.py scan.xml\n"
            "    python nmap_parser.py scan.xml --format json  # JSON output\n"
            "    python nmap_parser.py scan.xml --format csv   # CSV for spreadsheets\n"
            "\"\"\"\n"
            "import argparse\n"
            "import csv\n"
            "import json\n"
            "import sys\n"
            "import xml.etree.ElementTree as ET\n"
            "from dataclasses import dataclass, field, asdict\n"
            "from pathlib import Path\n"
            "from typing import Optional\n\n\n"
            "@dataclass\n"
            "class Service:\n"
            "    port: int\n"
            "    protocol: str\n"
            "    state: str\n"
            "    name: str\n"
            "    product: str = \"\"\n"
            "    version: str = \"\"\n"
            "    extra_info: str = \"\"\n"
            "    scripts: list = field(default_factory=list)\n\n\n"
            "@dataclass\n"
            "class Host:\n"
            "    ip: str\n"
            "    hostname: str = \"\"\n"
            "    state: str = \"unknown\"\n"
            "    os_guess: str = \"\"\n"
            "    os_accuracy: int = 0\n"
            "    services: list = field(default_factory=list)\n\n"
            "    @property\n"
            "    def open_port_count(self) -> int:\n"
            "        return sum(1 for s in self.services if s.state == \"open\")\n\n"
            "    @property\n"
            "    def risk_score(self) -> str:\n"
            "        \"\"\"Simple heuristic risk scoring.\"\"\"\n"
            "        risky_ports = {21, 22, 23, 25, 80, 443, 445, 1433, 3306, 3389, 5985, 5986}\n"
            "        risky_services = {s for s in self.services if s.port in risky_ports and s.state == \"open\"}\n"
            "        if len(risky_services) >= 5 or 3389 in {s.port for s in risky_services}:\n"
            "            return \"HIGH\"\n"
            "        elif len(risky_services) >= 2:\n"
            "            return \"MEDIUM\"\n"
            "        elif risky_services:\n"
            "            return \"LOW\"\n"
            "        return \"INFO\"\n\n\n"
            "def parse_nmap_xml(xml_path: str) -> list[Host]:\n"
            "    \"\"\"Parse Nmap XML and return list of Host objects.\"\"\"\n"
            "    tree = ET.parse(xml_path)\n"
            "    root = tree.getroot()\n"
            "    hosts = []\n\n"
            "    for host_elem in root.findall(\"host\"):\n"
            "        # IP address\n"
            "        addr_elem = host_elem.find(\".//address[@addrtype='ipv4']\")\n"
            "        if addr_elem is None:\n"
            "            continue\n"
            "        ip = addr_elem.get(\"addr\", \"\")\n\n"
            "        # Hostname\n"
            "        hostname_elem = host_elem.find(\".//hostname\")\n"
            "        hostname = hostname_elem.get(\"name\", \"\") if hostname_elem is not None else \"\"\n\n"
            "        # State\n"
            "        status_elem = host_elem.find(\"status\")\n"
            "        state = status_elem.get(\"state\", \"unknown\") if status_elem is not None else \"unknown\"\n\n"
            "        # OS detection\n"
            "        os_elem = host_elem.find(\".//osmatch\")\n"
            "        os_guess = os_elem.get(\"name\", \"\") if os_elem is not None else \"\"\n"
            "        os_acc = int(os_elem.get(\"accuracy\", 0)) if os_elem is not None else 0\n\n"
            "        # Services/ports\n"
            "        services = []\n"
            "        for port_elem in host_elem.findall(\".//port\"):\n"
            "            port_num = int(port_elem.get(\"portid\", 0))\n"
            "            protocol = port_elem.get(\"protocol\", \"tcp\")\n"
            "            state_elem = port_elem.find(\"state\")\n"
            "            port_state = state_elem.get(\"state\", \"\") if state_elem is not None else \"\"\n"
            "            svc_elem = port_elem.find(\"service\")\n"
            "            scripts = [\n"
            "                {\"id\": s.get(\"id\"), \"output\": s.get(\"output\", \"\")[:200]}\n"
            "                for s in port_elem.findall(\"script\")\n"
            "            ]\n"
            "            services.append(Service(\n"
            "                port=port_num, protocol=protocol, state=port_state,\n"
            "                name=svc_elem.get(\"name\", \"\") if svc_elem is not None else \"\",\n"
            "                product=svc_elem.get(\"product\", \"\") if svc_elem is not None else \"\",\n"
            "                version=svc_elem.get(\"version\", \"\") if svc_elem is not None else \"\",\n"
            "                scripts=scripts,\n"
            "            ))\n"
            "        hosts.append(Host(ip=ip, hostname=hostname, state=state,\n"
            "                         os_guess=os_guess, os_accuracy=os_acc, services=services))\n\n"
            "    return [h for h in hosts if h.state == \"up\"]\n\n\n"
            "def print_report(hosts: list[Host]):\n"
            "    \"\"\"Print a formatted pentest-ready report.\"\"\"\n"
            "    print(f\"\\n{'='*60}\")\n"
            "    print(f\"  NMAP SCAN REPORT â€” {len(hosts)} hosts up\")\n"
            "    print(f\"{'='*60}\\n\")\n"
            "    for host in sorted(hosts, key=lambda h: h.ip):\n"
            "        print(f\"[{host.risk_score}] {host.ip}  {host.hostname}\")\n"
            "        if host.os_guess:\n"
            "            print(f\"  OS: {host.os_guess} ({host.os_accuracy}% confidence)\")\n"
            "        open_svcs = [s for s in host.services if s.state == \"open\"]\n"
            "        for svc in open_svcs:\n"
            "            svc_str = f\"{svc.port}/{svc.protocol}  {svc.name}\"\n"
            "            if svc.product:\n"
            "                svc_str += f\"  [{svc.product} {svc.version}]\"\n"
            "            print(f\"  {svc_str}\")\n"
            "            for script in svc.scripts[:2]:\n"
            "                output_preview = script['output'].replace('\\n', ' ')[:100]\n"
            "                print(f\"    â†’ {script['id']}: {output_preview}\")\n"
            "        print()\n\n\n"
            "def main():\n"
            "    parser = argparse.ArgumentParser(description=\"Nmap XML Parser â€” Hancock CyberViser\")\n"
            "    parser.add_argument(\"xml_file\", help=\"Nmap XML output file\")\n"
            "    parser.add_argument(\"--format\", choices=[\"text\", \"json\", \"csv\"], default=\"text\")\n"
            "    parser.add_argument(\"--output\", help=\"Output file (default: stdout)\")\n"
            "    args = parser.parse_args()\n\n"
            "    hosts = parse_nmap_xml(args.xml_file)\n"
            "    print(f\"Parsed {len(hosts)} live hosts.\", file=sys.stderr)\n\n"
            "    if args.format == \"text\":\n"
            "        print_report(hosts)\n"
            "    elif args.format == \"json\":\n"
            "        output = json.dumps([asdict(h) for h in hosts], indent=2)\n"
            "        if args.output:\n"
            "            Path(args.output).write_text(output)\n"
            "        else:\n"
            "            print(output)\n"
            "    elif args.format == \"csv\":\n"
            "        rows = []\n"
            "        for h in hosts:\n"
            "            for s in h.services:\n"
            "                if s.state == \"open\":\n"
            "                    rows.append({\"ip\": h.ip, \"hostname\": h.hostname, \"os\": h.os_guess,\n"
            "                                  \"port\": s.port, \"protocol\": s.protocol,\n"
            "                                  \"service\": s.name, \"product\": s.product,\n"
            "                                  \"version\": s.version, \"risk\": h.risk_score})\n"
            "        out = args.output or \"nmap_report.csv\"\n"
            "        with open(out, \"w\", newline=\"\") as f:\n"
            "            writer = csv.DictWriter(f, fieldnames=rows[0].keys())\n"
            "            writer.writeheader(); writer.writerows(rows)\n"
            "        print(f\"CSV saved â†’ {out}\")\n\n\n"
            "if __name__ == \"__main__\":\n"
            "    main()\n"
            "```"
        ),
    },
    {
        "category": "siem_queries",
        "user": "Write Splunk SPL queries to detect common attack patterns: failed logins, lateral movement, data exfiltration.",
        "assistant": (
            "# Splunk SPL Hunting Queries â€” Hancock CyberViser\n\n"
            "## 1. Brute Force / Password Spray Detection\n"
            "```spl\n"
            "index=wineventlog EventCode=4625\n"
            "| bucket span=10m _time\n"
            "| stats count as failures dc(Account_Name) as unique_accounts by _time, src_ip\n"
            "| where failures > 20 AND unique_accounts > 5\n"
            "| eval attack_type=if(unique_accounts > 10, \"password_spray\", \"brute_force\")\n"
            "| sort -failures\n"
            "| table _time, src_ip, failures, unique_accounts, attack_type\n"
            "```\n\n"
            "## 2. Lateral Movement â€” Pass-the-Hash / PsExec\n"
            "```spl\n"
            "index=wineventlog EventCode=4624 Logon_Type=3\n"
            "| stats dc(host) as unique_dest values(host) as destinations count by Account_Name src_ip\n"
            "| where unique_dest > 3\n"
            "| eval risk=if(unique_dest > 10, \"HIGH\", \"MEDIUM\")\n"
            "| sort -unique_dest\n"
            "| table Account_Name, src_ip, unique_dest, destinations, risk\n"
            "```\n\n"
            "## 3. Data Exfiltration â€” Large Outbound Transfers\n"
            "```spl\n"
            "index=network src_zone=internal dest_zone=external\n"
            "| bucket span=1h _time\n"
            "| stats sum(bytes_out) as total_bytes_out by _time, src_ip, dest_ip\n"
            "| where total_bytes_out > 104857600  | 100MB threshold\n"
            "| eval total_mb=round(total_bytes_out/1048576, 2)\n"
            "| lookup threat_intel_ips ip as dest_ip OUTPUT verdict as ti_verdict\n"
            "| eval risk=if(isnotnull(ti_verdict), \"CRITICAL: Known Bad IP\", \"HIGH: Large Upload\")\n"
            "| sort -total_bytes_out\n"
            "| table _time, src_ip, dest_ip, total_mb, risk\n"
            "```\n\n"
            "## 4. PowerShell Suspicious Activity\n"
            "```spl\n"
            "index=wineventlog source=\"WinEventLog:Microsoft-Windows-PowerShell/Operational\"\n"
            "EventCode=4104\n"
            "| search ScriptBlockText IN (\"*IEX*\", \"*Invoke-Expression*\", \"*-EncodedCommand*\",\n"
            "                             \"*DownloadString*\", \"*WebClient*\", \"*bypass*\")\n"
            "| eval risk=case(\n"
            "    like(ScriptBlockText, \"%mimikatz%\"), \"CRITICAL\",\n"
            "    like(ScriptBlockText, \"%IEX*Download%\"), \"HIGH\",\n"
            "    like(ScriptBlockText, \"%-EncodedCommand%\"), \"MEDIUM\",\n"
            "    true(), \"LOW\")\n"
            "| table _time, ComputerName, UserID, risk, ScriptBlockText\n"
            "| sort -risk\n"
            "```\n\n"
            "## 5. New Local Admin Account Created\n"
            "```spl\n"
            "index=wineventlog EventCode=4732\n"
            "| search Group_Name=\"Administrators\"\n"
            "| eval alert=\"New local admin: \" + Member_Name + \" added to Administrators by \" + Account_Name\n"
            "| table _time, ComputerName, Member_Name, Account_Name, alert\n"
            "```\n\n"
            "## 6. DNS Exfiltration / Tunneling\n"
            "```spl\n"
            "index=dns\n"
            "| eval query_length=len(query)\n"
            "| stats count avg(query_length) as avg_len dc(query) as unique_queries by src_ip\n"
            "| where avg_len > 50 AND unique_queries > 100\n"
            "| eval risk=\"Possible DNS tunneling\"\n"
            "| table src_ip, count, avg_len, unique_queries, risk\n"
            "```\n\n"
            "## 7. Rare Process on Sensitive Hosts\n"
            "```spl\n"
            "index=wineventlog EventCode=4688 host IN (domain_controllers, file_servers)\n"
            "| stats count by New_Process_Name\n"
            "| where count < 3\n"
            "| eval alert=\"Rare process on sensitive host: \" + New_Process_Name\n"
            "| sort -count\n"
            "```"
        ),
    },
    {
        "category": "pentest_tools",
        "user": "Write a Python port scanner that uses threading for speed.",
        "assistant": (
            "âš ï¸ **Authorization Warning:** Only use this tool on systems you own or have explicit written permission to test. Unauthorized port scanning may be illegal.\n\n"
            "```python\n"
            "#!/usr/bin/env python3\n"
            "\"\"\"\n"
            "Fast Threaded Port Scanner â€” Hancock CyberViser\n"
            "For authorized penetration testing only.\n"
            "\n"
            "Usage:\n"
            "    python port_scanner.py -t 192.168.1.1 -p 1-1024\n"
            "    python port_scanner.py -t 192.168.1.0/24 -p 22,80,443,3389 --threads 200\n"
            "\"\"\"\n"
            "import argparse\n"
            "import ipaddress\n"
            "import socket\n"
            "import sys\n"
            "from concurrent.futures import ThreadPoolExecutor, as_completed\n"
            "from dataclasses import dataclass\n"
            "from typing import Optional\n\n\n"
            "COMMON_PORTS = [\n"
            "    21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445,\n"
            "    993, 995, 1723, 3306, 3389, 5900, 8080, 8443, 8888\n"
            "]\n\n\n"
            "@dataclass\n"
            "class PortResult:\n"
            "    host: str\n"
            "    port: int\n"
            "    state: str  # open / closed / filtered\n"
            "    banner: str = \"\"\n\n\n"
            "def scan_port(host: str, port: int, timeout: float = 1.0, grab_banner: bool = True) -> PortResult:\n"
            "    \"\"\"Scan a single port on a host.\"\"\"\n"
            "    try:\n"
            "        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
            "            sock.settimeout(timeout)\n"
            "            result = sock.connect_ex((host, port))\n"
            "            if result == 0:\n"
            "                banner = \"\"\n"
            "                if grab_banner:\n"
            "                    try:\n"
            "                        sock.settimeout(2.0)\n"
            "                        # Send HTTP HEAD for web ports\n"
            "                        if port in (80, 8080, 8000):\n"
            "                            sock.send(b\"HEAD / HTTP/1.0\\r\\n\\r\\n\")\n"
            "                        banner = sock.recv(1024).decode(\"utf-8\", errors=\"replace\").split(\"\\n\")[0][:100]\n"
            "                    except Exception:\n"
            "                        pass\n"
            "                return PortResult(host, port, \"open\", banner)\n"
            "            return PortResult(host, port, \"closed\")\n"
            "    except socket.timeout:\n"
            "        return PortResult(host, port, \"filtered\")\n"
            "    except OSError:\n"
            "        return PortResult(host, port, \"error\")\n\n\n"
            "def parse_ports(port_spec: str) -> list[int]:\n"
            "    \"\"\"Parse port spec: '80', '1-1024', '22,80,443', or 'common'.\"\"\"\n"
            "    if port_spec == \"common\":\n"
            "        return COMMON_PORTS\n"
            "    ports: set[int] = set()\n"
            "    for part in port_spec.split(\",\"):\n"
            "        if \"-\" in part:\n"
            "            start, end = part.split(\"-\", 1)\n"
            "            ports.update(range(int(start), int(end) + 1))\n"
            "        else:\n"
            "            ports.add(int(part))\n"
            "    return sorted(ports)\n\n\n"
            "def scan_host(host: str, ports: list[int], threads: int = 100,\n"
            "               timeout: float = 1.0) -> list[PortResult]:\n"
            "    \"\"\"Scan all specified ports on a host using thread pool.\"\"\"\n"
            "    results = []\n"
            "    with ThreadPoolExecutor(max_workers=threads) as executor:\n"
            "        futures = {executor.submit(scan_port, host, port, timeout): port\n"
            "                   for port in ports}\n"
            "        for future in as_completed(futures):\n"
            "            result = future.result()\n"
            "            if result.state == \"open\":\n"
            "                results.append(result)\n"
            "    return sorted(results, key=lambda r: r.port)\n\n\n"
            "def main():\n"
            "    parser = argparse.ArgumentParser(\n"
            "        description=\"Port Scanner â€” Hancock CyberViser (authorized use only)\")\n"
            "    parser.add_argument(\"-t\", \"--target\", required=True,\n"
            "                        help=\"Target host, IP, or CIDR range\")\n"
            "    parser.add_argument(\"-p\", \"--ports\", default=\"common\",\n"
            "                        help=\"Ports: '80', '1-1024', '22,443', or 'common'\")\n"
            "    parser.add_argument(\"--threads\", type=int, default=100)\n"
            "    parser.add_argument(\"--timeout\", type=float, default=1.0)\n"
            "    args = parser.parse_args()\n\n"
            "    ports = parse_ports(args.ports)\n"
            "    print(f\"[*] Scanning {args.target} â€” {len(ports)} ports, {args.threads} threads\")\n\n"
            "    # Handle CIDR or single host\n"
            "    try:\n"
            "        network = ipaddress.ip_network(args.target, strict=False)\n"
            "        hosts = [str(ip) for ip in network.hosts()]\n"
            "    except ValueError:\n"
            "        hosts = [args.target]\n\n"
            "    for host in hosts:\n"
            "        open_ports = scan_host(host, ports, args.threads, args.timeout)\n"
            "        if open_ports:\n"
            "            print(f\"\\n[+] {host} â€” {len(open_ports)} open ports\")\n"
            "            for result in open_ports:\n"
            "                banner_str = f\"  [{result.banner}]\" if result.banner else \"\"\n"
            "                print(f\"  {result.port}/tcp  OPEN{banner_str}\")\n\n\n"
            "if __name__ == \"__main__\":\n"
            "    main()\n"
            "```"
        ),
    },
    {
        "category": "secure_code_review",
        "user": "Review this Python Flask code for security vulnerabilities:\n\n```python\nfrom flask import Flask, request\nimport subprocess\nimport sqlite3\n\napp = Flask(__name__)\n\n@app.route('/exec')\ndef execute():\n    cmd = request.args.get('cmd')\n    result = subprocess.run(cmd, shell=True, capture_output=True)\n    return result.stdout\n\n@app.route('/user')\ndef get_user():\n    uid = request.args.get('id')\n    conn = sqlite3.connect('users.db')\n    cursor = conn.cursor()\n    cursor.execute(f\"SELECT * FROM users WHERE id = {uid}\")\n    return cursor.fetchone()\n```",
        "assistant": (
            "## Security Code Review â€” Critical Vulnerabilities Found\n\n"
            "### ðŸ”´ CRITICAL: OS Command Injection (CWE-78)\n"
            "**Location:** `/exec` endpoint, line: `subprocess.run(cmd, shell=True, ...)`\n\n"
            "**Issue:** `cmd` is taken directly from `request.args` (user-controlled) and passed to "
            "`subprocess.run` with `shell=True`. This allows arbitrary OS command execution:\n"
            "```\n"
            "GET /exec?cmd=ls%3Bcat%20/etc/passwd%3Bwhoami\n"
            "# Executes: ls; cat /etc/passwd; whoami\n"
            "```\n\n"
            "**Fix:**\n"
            "```python\n"
            "# Option 1: Remove the endpoint entirely (preferred)\n"
            "# Option 2: If OS commands are required, use a strict whitelist\n"
            "import shlex\n\n"
            "ALLOWED_COMMANDS = {\"date\", \"uptime\", \"hostname\"}  # strict allowlist\n\n"
            "@app.route('/exec')\n"
            "def execute():\n"
            "    cmd = request.args.get('cmd', '')\n"
            "    if cmd not in ALLOWED_COMMANDS:\n"
            "        return 'Unauthorized command', 403\n"
            "    # Never use shell=True with user input\n"
            "    result = subprocess.run([cmd], shell=False, capture_output=True, text=True, timeout=10)\n"
            "    return result.stdout\n"
            "```\n\n"
            "### ðŸ”´ CRITICAL: SQL Injection (CWE-89)\n"
            "**Location:** `/user` endpoint, line: `cursor.execute(f\"SELECT * FROM users WHERE id = {uid}\")`\n\n"
            "**Issue:** `uid` is user-controlled and directly interpolated into the SQL query. "
            "Attacker can extract the entire database or drop tables:\n"
            "```\n"
            "GET /user?id=1 UNION SELECT username,password,3,4 FROM users--\n"
            "GET /user?id=1; DROP TABLE users--\n"
            "```\n\n"
            "**Fix:** Use parameterized queries (never string interpolation):\n"
            "```python\n"
            "@app.route('/user')\n"
            "def get_user():\n"
            "    uid = request.args.get('id', '')\n"
            "    # Validate: only allow integer IDs\n"
            "    if not uid.isdigit():\n"
            "        return 'Invalid ID', 400\n"
            "    conn = sqlite3.connect('users.db')\n"
            "    cursor = conn.cursor()\n"
            "    # âœ… Parameterized query â€” SQL injection impossible\n"
            "    cursor.execute(\"SELECT id, username, email FROM users WHERE id = ?\", (int(uid),))\n"
            "    row = cursor.fetchone()\n"
            "    conn.close()\n"
            "    if not row:\n"
            "        return 'User not found', 404\n"
            "    return {'id': row[0], 'username': row[1], 'email': row[2]}\n"
            "```\n\n"
            "### ðŸŸ¡ HIGH: Missing Authentication\n"
            "Neither endpoint has authentication. The `/exec` command injection becomes internet-accessible "
            "if this service is exposed.\n"
            "```python\n"
            "from functools import wraps\n"
            "from flask import request\n\n"
            "def require_api_key(f):\n"
            "    @wraps(f)\n"
            "    def decorated(*args, **kwargs):\n"
            "        key = request.headers.get('X-API-Key')\n"
            "        if key != os.environ.get('API_KEY'):\n"
            "            return 'Unauthorized', 401\n"
            "        return f(*args, **kwargs)\n"
            "    return decorated\n"
            "```\n\n"
            "### ðŸŸ¡ MEDIUM: Sensitive Data Exposure\n"
            "`SELECT *` returns all columns including potentially hashed passwords. "
            "Always select only required columns.\n\n"
            "### Summary\n"
            "| Severity | Issue | CWE | CVSS |\n"
            "|----------|-------|-----|------|\n"
            "| ðŸ”´ Critical | OS Command Injection | CWE-78 | 9.8 |\n"
            "| ðŸ”´ Critical | SQL Injection | CWE-89 | 9.8 |\n"
            "| ðŸŸ¡ High | Missing Authentication | CWE-306 | 8.6 |\n"
            "| ðŸŸ¡ Medium | Sensitive Data Exposure | CWE-200 | 6.5 |"
        ),
    },
    {
        "category": "siem_queries",
        "user": "Write Microsoft Sentinel KQL queries to detect Azure AD attacks: MFA bypass, impossible travel, token theft.",
        "assistant": (
            "# Microsoft Sentinel KQL Hunting Queries â€” Hancock CyberViser\n\n"
            "## 1. MFA Bypass / Adversary-in-the-Middle (AiTM)\n"
            "```kql\n"
            "SigninLogs\n"
            "| where TimeGenerated > ago(1h)\n"
            "| where ResultType == 0  // successful sign-in\n"
            "| where AuthenticationRequirement == \"singleFactorAuthentication\"\n"
            "| where ConditionalAccessStatus == \"success\"\n"
            "| where AppDisplayName in (\"Office 365\", \"Microsoft 365\", \"Azure Portal\")\n"
            "| project TimeGenerated, UserPrincipalName, IPAddress, Location, AppDisplayName,\n"
            "          DeviceDetail, AuthenticationDetails, RiskState\n"
            "| extend IsSuspicious = iff(RiskState in (\"atRisk\", \"confirmedCompromised\"), true, false)\n"
            "| where IsSuspicious == true or AuthenticationDetails !contains \"MFA\"\n"
            "```\n\n"
            "## 2. Impossible Travel Detection\n"
            "```kql\n"
            "let travel_threshold_km = 500;\n"
            "let time_window = 30min;\n"
            "SigninLogs\n"
            "| where TimeGenerated > ago(24h) and ResultType == 0\n"
            "| extend lat = toreal(LocationDetails.geoCoordinates.latitude)\n"
            "| extend lon = toreal(LocationDetails.geoCoordinates.longitude)\n"
            "| where isnotnull(lat)\n"
            "| sort by UserPrincipalName, TimeGenerated asc\n"
            "| extend prev_lat  = prev(lat,  1, real(null)),\n"
            "         prev_lon  = prev(lon,  1, real(null)),\n"
            "         prev_time = prev(TimeGenerated, 1),\n"
            "         prev_user = prev(UserPrincipalName, 1)\n"
            "| where UserPrincipalName == prev_user\n"
            "| extend elapsed_min = datetime_diff('minute', TimeGenerated, prev_time)\n"
            "| extend dist_km = geo_distance_2points(lon, lat, prev_lon, prev_lat) / 1000\n"
            "| extend speed_kmh = iff(elapsed_min > 0, dist_km / (elapsed_min / 60.0), real(null))\n"
            "| where speed_kmh > 900  // faster than commercial flight\n"
            "| project TimeGenerated, UserPrincipalName, IPAddress, dist_km, elapsed_min, speed_kmh\n"
            "```\n\n"
            "## 3. OAuth Token Theft â€” Suspicious Token Use\n"
            "```kql\n"
            "AADServicePrincipalSignInLogs\n"
            "| union SigninLogs\n"
            "| where TimeGenerated > ago(4h)\n"
            "| where ResultType == 0\n"
            "| extend TokenAge = datetime_diff('hour', TimeGenerated, CreatedDateTime)\n"
            "| where TokenAge > 12  // token used long after issuance\n"
            "| where IPAddress !startswith \"10.\" and IPAddress !startswith \"192.168.\"\n"
            "| summarize count(), make_set(IPAddress), make_set(Location) by UserPrincipalName, AppDisplayName\n"
            "| where array_length(set_IPAddress) > 3  // used from many IPs\n"
            "```\n\n"
            "## 4. Azure AD Enumeration via Graph API\n"
            "```kql\n"
            "AuditLogs\n"
            "| where TimeGenerated > ago(1h)\n"
            "| where OperationName in (\n"
            "    \"List group members\", \"List groups\", \"List users\",\n"
            "    \"List servicePrincipals\", \"Get application\"\n"
            "  )\n"
            "| summarize ops=count(), ops_list=make_set(OperationName) by\n"
            "    InitiatedBy=tostring(InitiatedBy.user.userPrincipalName),\n"
            "    bin(TimeGenerated, 5m)\n"
            "| where ops > 20\n"
            "| extend alert = strcat(\"Azure AD enum: \", ops, \" read ops in 5 min\")\n"
            "```\n\n"
            "## 5. Global Admin Role Assignment\n"
            "```kql\n"
            "AuditLogs\n"
            "| where OperationName == \"Add member to role\"\n"
            "| extend RoleName = tostring(TargetResources[0].modifiedProperties[1].newValue)\n"
            "| where RoleName contains \"Global Administrator\"\n"
            "| project TimeGenerated,\n"
            "          Actor = tostring(InitiatedBy.user.userPrincipalName),\n"
            "          Target = tostring(TargetResources[0].userPrincipalName),\n"
            "          RoleName\n"
            "| extend alert = strcat(\"CRITICAL: \", Target, \" granted Global Admin by \", Actor)\n"
            "```"
        ),
    },
    {
        "category": "security_automation",
        "user": "Write a Python script to parse and alert on Windows Event Log security events using python-evtx.",
        "assistant": (
            "```python\n"
            "#!/usr/bin/env python3\n"
            "\"\"\"\n"
            "Windows Event Log Security Monitor â€” Hancock CyberViser\n"
            "Parses .evtx files and alerts on critical security events.\n"
            "\n"
            "Usage:\n"
            "    python evtx_monitor.py Security.evtx\n"
            "    python evtx_monitor.py Security.evtx --event-ids 4624,4625,4688 --output alerts.json\n"
            "\n"
            "Requirements: pip install python-evtx lxml\n"
            "\"\"\"\n"
            "import argparse\n"
            "import json\n"
            "import re\n"
            "import sys\n"
            "from collections import Counter, defaultdict\n"
            "from datetime import datetime\n"
            "from pathlib import Path\n"
            "\n"
            "try:\n"
            "    import Evtx.Evtx as evtx\n"
            "    import Evtx.Views as e_views\n"
            "    from lxml import etree\n"
            "except ImportError:\n"
            "    sys.exit(\"Install: pip install python-evtx lxml\")\n\n\n"
            "# High-value Windows Security Event IDs\n"
            "CRITICAL_EVENTS = {\n"
            "    4624: (\"Logon Success\",           \"INFO\"),\n"
            "    4625: (\"Logon Failure\",           \"MEDIUM\"),\n"
            "    4648: (\"Explicit Credential Use\", \"MEDIUM\"),\n"
            "    4688: (\"Process Created\",         \"INFO\"),\n"
            "    4697: (\"Service Installed\",       \"HIGH\"),\n"
            "    4698: (\"Scheduled Task Created\",  \"HIGH\"),\n"
            "    4700: (\"Scheduled Task Enabled\",  \"HIGH\"),\n"
            "    4719: (\"Audit Policy Changed\",    \"CRITICAL\"),\n"
            "    4720: (\"User Account Created\",    \"HIGH\"),\n"
            "    4728: (\"Member Added to Group\",   \"HIGH\"),\n"
            "    4732: (\"Local Admin Added\",       \"CRITICAL\"),\n"
            "    4740: (\"Account Locked Out\",      \"MEDIUM\"),\n"
            "    4768: (\"Kerberos TGT Request\",    \"INFO\"),\n"
            "    4769: (\"Kerberos Service Ticket\",  \"INFO\"),\n"
            "    4771: (\"Kerberos Pre-auth Fail\",  \"MEDIUM\"),\n"
            "    7045: (\"New Service Installed\",   \"HIGH\"),\n"
            "}\n\n"
            "SUSPICIOUS_PROCESSES = {\n"
            "    \"mimikatz\", \"meterpreter\", \"cobaltstrike\", \"psexec\",\n"
            "    \"wce\", \"fgdump\", \"pwdump\", \"procdump\", \"lsass\",\n"
            "}\n\n\n"
            "def parse_event(xml_str: str) -> dict:\n"
            "    \"\"\"Parse a single event XML record.\"\"\"\n"
            "    try:\n"
            "        root = etree.fromstring(xml_str.encode())\n"
            "        ns = {'e': 'http://schemas.microsoft.com/win/2004/08/events/event'}\n\n"
            "        system   = root.find('e:System', ns)\n"
            "        event_id = int(system.findtext('e:EventID', '0', ns))\n"
            "        time_str = system.findtext('e:TimeCreated/[@SystemTime]', '', ns)\n"
            "        # Try attribute\n"
            "        tc_elem  = system.find('e:TimeCreated', ns)\n"
            "        time_str = tc_elem.get('SystemTime', '') if tc_elem is not None else ''\n"
            "        computer = system.findtext('e:Computer', '', ns)\n\n"
            "        # Extract EventData fields\n"
            "        data = {}\n"
            "        for item in root.findall('.//e:Data', ns):\n"
            "            name = item.get('Name', '')\n"
            "            data[name] = (item.text or '').strip()\n\n"
            "        return {'event_id': event_id, 'time': time_str,\n"
            "                'computer': computer, 'data': data}\n"
            "    except Exception:\n"
            "        return {}\n\n\n"
            "def analyze_event(event: dict) -> list[dict]:\n"
            "    \"\"\"Generate alerts from a parsed event.\"\"\"\n"
            "    alerts = []\n"
            "    eid  = event.get('event_id', 0)\n"
            "    data = event.get('data', {})\n\n"
            "    if eid not in CRITICAL_EVENTS:\n"
            "        return []\n\n"
            "    desc, severity = CRITICAL_EVENTS[eid]\n"
            "    base_alert = {\n"
            "        'event_id':  eid,\n"
            "        'timestamp': event.get('time', ''),\n"
            "        'computer':  event.get('computer', ''),\n"
            "        'event':     desc,\n"
            "        'severity':  severity,\n"
            "        'details':   data,\n"
            "    }\n\n"
            "    # Escalate: admin group additions\n"
            "    if eid == 4732 and 'Administrators' in data.get('GroupName', ''):\n"
            "        base_alert['severity'] = 'CRITICAL'\n"
            "        base_alert['alert'] = f\"Local admin added: {data.get('MemberName')} by {data.get('SubjectUserName')}\"\n\n"
            "    # Escalate: suspicious process names\n"
            "    elif eid == 4688:\n"
            "        proc = data.get('NewProcessName', '').lower()\n"
            "        if any(s in proc for s in SUSPICIOUS_PROCESSES):\n"
            "            base_alert['severity'] = 'CRITICAL'\n"
            "            base_alert['alert'] = f\"Suspicious process: {data.get('NewProcessName')}\"\n"
            "        else:\n"
            "            return []  # skip normal process creates\n\n"
            "    # Brute-force: count failures externally\n"
            "    elif eid == 4625:\n"
            "        base_alert['alert'] = (\n"
            "            f\"Login failure: {data.get('TargetUserName')} from {data.get('IpAddress')}\"\n"
            "        )\n\n"
            "    alerts.append(base_alert)\n"
            "    return alerts\n\n\n"
            "def process_evtx(evtx_path: str, filter_ids: set = None) -> list[dict]:\n"
            "    \"\"\"Parse .evtx file and return all alerts.\"\"\"\n"
            "    all_alerts = []\n"
            "    with evtx.Evtx(evtx_path) as log:\n"
            "        for record in log.records():\n"
            "            xml_str = record.xml()\n"
            "            event   = parse_event(xml_str)\n"
            "            if not event:\n"
            "                continue\n"
            "            if filter_ids and event['event_id'] not in filter_ids:\n"
            "                continue\n"
            "            all_alerts.extend(analyze_event(event))\n"
            "    return all_alerts\n\n\n"
            "def main():\n"
            "    parser = argparse.ArgumentParser(description=\"EVTX Security Monitor â€” Hancock\")\n"
            "    parser.add_argument(\"evtx_file\", help=\"Windows .evtx log file\")\n"
            "    parser.add_argument(\"--event-ids\", help=\"Comma-separated event IDs to filter\")\n"
            "    parser.add_argument(\"--output\", default=\"evtx_alerts.json\")\n"
            "    parser.add_argument(\"--min-severity\", choices=[\"INFO\",\"MEDIUM\",\"HIGH\",\"CRITICAL\"],\n"
            "                        default=\"MEDIUM\")\n"
            "    args = parser.parse_args()\n\n"
            "    filter_ids = None\n"
            "    if args.event_ids:\n"
            "        filter_ids = {int(x) for x in args.event_ids.split(',')}\n\n"
            "    severity_order = {\"INFO\":0,\"MEDIUM\":1,\"HIGH\":2,\"CRITICAL\":3}\n"
            "    min_sev = severity_order[args.min_severity]\n\n"
            "    print(f\"[*] Parsing {args.evtx_file} ...\", flush=True)\n"
            "    alerts = process_evtx(args.evtx_file, filter_ids)\n"
            "    alerts = [a for a in alerts if severity_order.get(a['severity'], 0) >= min_sev]\n"
            "    print(f\"[+] {len(alerts)} alerts (severity >= {args.min_severity})\")\n\n"
            "    # Summary\n"
            "    sev_counts = Counter(a['severity'] for a in alerts)\n"
            "    for sev in ['CRITICAL','HIGH','MEDIUM','INFO']:\n"
            "        if sev_counts.get(sev):\n"
            "            print(f\"  {sev}: {sev_counts[sev]}\")\n\n"
            "    Path(args.output).write_text(json.dumps(alerts, indent=2, default=str))\n"
            "    print(f\"\\nâœ… Saved â†’ {args.output}\")\n\n\n"
            "if __name__ == '__main__':\n"
            "    main()\n"
            "```"
        ),
    },
    {
        "category": "secure_code_review",
        "user": "Review this Dockerfile for security issues and provide a hardened version.",
        "assistant": (
            "## Dockerfile Security Review â€” Hancock CyberViser\n\n"
            "**Original (insecure):**\n"
            "```dockerfile\n"
            "FROM ubuntu:latest\n"
            "RUN apt-get update && apt-get install -y python3 python3-pip\n"
            "COPY . /app\n"
            "WORKDIR /app\n"
            "RUN pip install -r requirements.txt\n"
            "EXPOSE 5000\n"
            "CMD [\"python3\", \"app.py\"]\n"
            "```\n\n"
            "### Issues Found\n\n"
            "| Severity | Issue |\n"
            "|----------|-------|\n"
            "| ðŸ”´ HIGH | `FROM ubuntu:latest` â€” unpinned tag, supply chain risk |\n"
            "| ðŸ”´ HIGH | Running as root (no USER directive) |\n"
            "| ðŸŸ¡ MEDIUM | `COPY . /app` copies everything including `.env`, `.git` |\n"
            "| ðŸŸ¡ MEDIUM | No `pip` version pinning |\n"
            "| ðŸŸ¢ LOW | No health check |\n"
            "| ðŸŸ¢ LOW | No read-only filesystem |\n\n"
            "### Hardened Version\n"
            "```dockerfile\n"
            "# Pin exact digest â€” prevents supply-chain tag mutation attacks\n"
            "FROM python:3.11-slim-bookworm\n\n"
            "# Create non-root user\n"
            "RUN groupadd --gid 1001 appgroup && \\\n"
            "    useradd --uid 1001 --gid appgroup --shell /bin/sh --create-home appuser\n\n"
            "WORKDIR /app\n\n"
            "# Install deps as root BEFORE switching user (owns /app)\n"
            "COPY requirements.txt .\n"
            "RUN pip install --no-cache-dir --upgrade pip==24.0 && \\\n"
            "    pip install --no-cache-dir -r requirements.txt\n\n"
            "# Copy app â€” use .dockerignore to exclude .env, .git, __pycache__, tests\n"
            "COPY --chown=appuser:appgroup . .\n\n"
            "# Drop to non-root\n"
            "USER appuser\n\n"
            "EXPOSE 5000\n\n"
            "HEALTHCHECK --interval=30s --timeout=10s --retries=3 \\\n"
            "    CMD python3 -c \"import urllib.request; urllib.request.urlopen('http://localhost:5000/health')\"\n\n"
            "CMD [\"python3\", \"-m\", \"gunicorn\", \"--bind\", \"0.0.0.0:5000\", \"--workers\", \"2\", \"app:app\"]\n"
            "```\n\n"
            "### Required `.dockerignore`\n"
            "```\n"
            ".env\n"
            ".env.*\n"
            ".git/\n"
            "__pycache__/\n"
            "*.pyc\n"
            "tests/\n"
            "*.md\n"
            ".DS_Store\n"
            "```\n\n"
            "### Runtime Security (docker run)\n"
            "```bash\n"
            "docker run \\\n"
            "  --read-only \\\n"
            "  --tmpfs /tmp \\\n"
            "  --cap-drop ALL \\\n"
            "  --security-opt no-new-privileges:true \\\n"
            "  --memory 512m \\\n"
            "  -e API_KEY=\"$(cat /run/secrets/api_key)\" \\\n"
            "  myapp:latest\n"
            "```"
        ),
    },
    {
        "category": "security_automation",
        "user": "Write a Python script to monitor file system changes and alert on suspicious modifications (like OSSEC/Wazuh but simpler).",
        "assistant": (
            "```python\n"
            "#!/usr/bin/env python3\n"
            "\"\"\"\n"
            "File Integrity Monitor (FIM) â€” Hancock CyberViser\n"
            "Monitors critical directories for unauthorized changes.\n"
            "\n"
            "Usage:\n"
            "    python fim.py --baseline /etc /bin /usr/bin  # create baseline\n"
            "    python fim.py --monitor                      # watch for changes\n"
            "\n"
            "Requirements: pip install watchdog rich\n"
            "\"\"\"\n"
            "import argparse\n"
            "import hashlib\n"
            "import json\n"
            "import os\n"
            "import sys\n"
            "import time\n"
            "from datetime import datetime\n"
            "from pathlib import Path\n"
            "from typing import Optional\n\n"
            "try:\n"
            "    from watchdog.events import FileSystemEventHandler\n"
            "    from watchdog.observers import Observer\n"
            "    from rich.console import Console\n"
            "    from rich import print as rprint\n"
            "except ImportError:\n"
            "    sys.exit(\"Install: pip install watchdog rich\")\n\n\n"
            "BASELINE_FILE = Path(\"/var/lib/fim/baseline.json\")\n"
            "ALERT_LOG     = Path(\"/var/log/fim_alerts.jsonl\")\n"
            "console       = Console()\n\n\n"
            "def hash_file(path: str) -> Optional[str]:\n"
            "    \"\"\"Compute SHA-256 hash of a file.\"\"\"\n"
            "    try:\n"
            "        h = hashlib.sha256()\n"
            "        with open(path, 'rb') as f:\n"
            "            while chunk := f.read(65536):\n"
            "                h.update(chunk)\n"
            "        return h.hexdigest()\n"
            "    except (PermissionError, FileNotFoundError, OSError):\n"
            "        return None\n\n\n"
            "def build_baseline(watch_dirs: list[str]) -> dict:\n"
            "    \"\"\"Create SHA-256 baseline for all files in watch directories.\"\"\"\n"
            "    baseline = {}\n"
            "    for watch_dir in watch_dirs:\n"
            "        console.log(f\"[cyan]Scanning {watch_dir}...\")\n"
            "        for root, _, files in os.walk(watch_dir):\n"
            "            for fname in files:\n"
            "                fpath = os.path.join(root, fname)\n"
            "                file_hash = hash_file(fpath)\n"
            "                if file_hash:\n"
            "                    stat = os.stat(fpath)\n"
            "                    baseline[fpath] = {\n"
            "                        'sha256': file_hash,\n"
            "                        'size': stat.st_size,\n"
            "                        'mtime': stat.st_mtime,\n"
            "                        'mode': oct(stat.st_mode),\n"
            "                    }\n"
            "    return baseline\n\n\n"
            "def log_alert(event_type: str, path: str, details: dict):\n"
            "    \"\"\"Write alert to JSONL log and console.\"\"\"\n"
            "    alert = {\n"
            "        'timestamp': datetime.utcnow().isoformat() + 'Z',\n"
            "        'event': event_type,\n"
            "        'path': path,\n"
            "        **details,\n"
            "    }\n"
            "    ALERT_LOG.parent.mkdir(parents=True, exist_ok=True)\n"
            "    with open(ALERT_LOG, 'a') as f:\n"
            "        f.write(json.dumps(alert) + '\\n')\n\n"
            "    severity = details.get('severity', 'MEDIUM')\n"
            "    color = {'CRITICAL': 'red', 'HIGH': 'yellow', 'MEDIUM': 'magenta'}.get(severity, 'white')\n"
            "    console.print(f\"[bold {color}][{severity}] {event_type}: {path}[/bold {color}]\")\n\n\n"
            "class FIMHandler(FileSystemEventHandler):\n"
            "    \"\"\"Watchdog event handler that checks against baseline.\"\"\"\n\n"
            "    CRITICAL_PATHS = {'/etc/passwd', '/etc/shadow', '/etc/sudoers',\n"
            "                      '/etc/crontab', '/etc/hosts', '/bin/bash', '/bin/sh'}\n\n"
            "    def __init__(self, baseline: dict):\n"
            "        self.baseline = baseline\n\n"
            "    def _severity(self, path: str) -> str:\n"
            "        return 'CRITICAL' if path in self.CRITICAL_PATH else 'HIGH'\n\n"
            "    def on_modified(self, event):\n"
            "        if event.is_directory:\n"
            "            return\n"
            "        path = event.src_path\n"
            "        new_hash = hash_file(path)\n"
            "        old_info = self.baseline.get(path)\n"
            "        severity = 'CRITICAL' if path in self.CRITICAL_PATHS else 'HIGH'\n"
            "        if old_info and new_hash and new_hash != old_info['sha256']:\n"
            "            log_alert('FILE_MODIFIED', path, {\n"
            "                'severity': severity,\n"
            "                'old_hash': old_info['sha256'],\n"
            "                'new_hash': new_hash,\n"
            "            })\n\n"
            "    def on_created(self, event):\n"
            "        if event.is_directory:\n"
            "            return\n"
            "        path = event.src_path\n"
            "        new_hash = hash_file(path)\n"
            "        log_alert('FILE_CREATED', path, {\n"
            "            'severity': 'MEDIUM',\n"
            "            'sha256': new_hash or 'unreadable',\n"
            "        })\n\n"
            "    def on_deleted(self, event):\n"
            "        if event.is_directory:\n"
            "            return\n"
            "        severity = 'CRITICAL' if event.src_path in self.CRITICAL_PATHS else 'MEDIUM'\n"
            "        log_alert('FILE_DELETED', event.src_path, {'severity': severity})\n\n\n"
            "def main():\n"
            "    parser = argparse.ArgumentParser(description=\"FIM â€” Hancock CyberViser\")\n"
            "    parser.add_argument('--baseline', nargs='+', help='Create baseline for these dirs')\n"
            "    parser.add_argument('--monitor', action='store_true', help='Start monitoring')\n"
            "    parser.add_argument('--baseline-file', default=str(BASELINE_FILE))\n"
            "    args = parser.parse_args()\n\n"
            "    bl_path = Path(args.baseline_file)\n\n"
            "    if args.baseline:\n"
            "        console.print(\"[cyan]Building baseline...\")\n"
            "        baseline = build_baseline(args.baseline)\n"
            "        bl_path.parent.mkdir(parents=True, exist_ok=True)\n"
            "        bl_path.write_text(json.dumps(baseline, indent=2))\n"
            "        console.print(f\"[green]âœ… Baseline saved: {len(baseline)} files â†’ {bl_path}\")\n\n"
            "    elif args.monitor:\n"
            "        if not bl_path.exists():\n"
            "            sys.exit(f\"No baseline found at {bl_path}. Run --baseline first.\")\n"
            "        baseline = json.loads(bl_path.read_text())\n"
            "        watch_dirs = list({os.path.dirname(p) for p in baseline.keys()})\n"
            "        console.print(f\"[cyan]Monitoring {len(watch_dirs)} dirs | {len(baseline)} files in baseline\")\n\n"
            "        handler  = FIMHandler(baseline)\n"
            "        observer = Observer()\n"
            "        for d in watch_dirs:\n"
            "            observer.schedule(handler, d, recursive=True)\n"
            "        observer.start()\n"
            "        try:\n"
            "            while True:\n"
            "                time.sleep(1)\n"
            "        except KeyboardInterrupt:\n"
            "            observer.stop()\n"
            "        observer.join()\n"
            "    else:\n"
            "        parser.print_help()\n\n\n"
            "if __name__ == '__main__':\n"
            "    main()\n"
            "```"
        ),
    },
    {
        "category": "secure_coding",
        "user": "Write a Python function to implement JWT authentication with proper security controls (expiry, algorithm pinning, secret rotation).",
        "assistant": (
            "```python\n"
            "\"\"\"JWT Authentication â€” Hancock CyberViser.\n"
            "Production-grade JWT with HS256/RS256 support, expiry, refresh tokens, and rotation.\n"
            "Requirements: pip install PyJWT cryptography python-dotenv\n"
            "\"\"\"\n"
            "import os\n"
            "import secrets\n"
            "from datetime import datetime, timedelta, timezone\n"
            "from typing import Optional\n\n"
            "import jwt\n"
            "from jwt.exceptions import ExpiredSignatureError, InvalidTokenError\n\n\n"
            "# â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "ACCESS_TOKEN_EXPIRE  = int(os.getenv('JWT_ACCESS_EXPIRE_MINUTES', '15'))\n"
            "REFRESH_TOKEN_EXPIRE = int(os.getenv('JWT_REFRESH_EXPIRE_DAYS', '7'))\n"
            "ALGORITHM = 'HS256'  # Use 'RS256' for distributed systems\n\n"
            "def _get_secret() -> str:\n"
            "    secret = os.getenv('JWT_SECRET_KEY', '')\n"
            "    if not secret or len(secret) < 32:\n"
            "        raise ValueError(\n"
            "            'JWT_SECRET_KEY must be set and at least 32 chars. '\n"
            "            f'Generate with: python3 -c \"import secrets; print(secrets.token_hex(32))\"'\n"
            "        )\n"
            "    return secret\n\n\n"
            "# â”€â”€ Token Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "def create_access_token(subject: str, extra_claims: Optional[dict] = None) -> str:\n"
            "    \"\"\"Create a short-lived access JWT.\"\"\"\n"
            "    now = datetime.now(tz=timezone.utc)\n"
            "    payload = {\n"
            "        'sub': subject,\n"
            "        'iat': now,\n"
            "        'exp': now + timedelta(minutes=ACCESS_TOKEN_EXPIRE),\n"
            "        'nbf': now,\n"
            "        'jti': secrets.token_hex(16),  # unique token ID for revocation\n"
            "        'type': 'access',\n"
            "        **(extra_claims or {}),\n"
            "    }\n"
            "    return jwt.encode(payload, _get_secret(), algorithm=ALGORITHM)\n\n\n"
            "def create_refresh_token(subject: str) -> str:\n"
            "    \"\"\"Create a long-lived refresh JWT (store hash in DB for revocation).\"\"\"\n"
            "    now = datetime.now(tz=timezone.utc)\n"
            "    payload = {\n"
            "        'sub': subject,\n"
            "        'iat': now,\n"
            "        'exp': now + timedelta(days=REFRESH_TOKEN_EXPIRE),\n"
            "        'jti': secrets.token_hex(16),\n"
            "        'type': 'refresh',\n"
            "    }\n"
            "    return jwt.encode(payload, _get_secret(), algorithm=ALGORITHM)\n\n\n"
            "# â”€â”€ Token Verification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "def verify_token(token: str, token_type: str = 'access') -> dict:\n"
            "    \"\"\"\n"
            "    Decode and validate a JWT.\n"
            "    Returns payload dict on success. Raises ValueError on failure.\n\n"
            "    Security controls:\n"
            "    - Algorithm pinned to HS256 (prevents 'alg:none' attack)\n"
            "    - Expiry checked automatically by PyJWT\n"
            "    - nbf (not-before) checked automatically\n"
            "    - Token type validated to prevent access/refresh token confusion\n"
            "    \"\"\"\n"
            "    try:\n"
            "        payload = jwt.decode(\n"
            "            token,\n"
            "            _get_secret(),\n"
            "            algorithms=[ALGORITHM],  # NEVER use algorithms=['*'] or allow 'none'\n"
            "            options={\n"
            "                'verify_exp': True,\n"
            "                'verify_nbf': True,\n"
            "                'verify_iat': True,\n"
            "                'require': ['exp', 'sub', 'iat', 'jti', 'type'],\n"
            "            },\n"
            "        )\n"
            "    except ExpiredSignatureError:\n"
            "        raise ValueError('Token has expired')\n"
            "    except InvalidTokenError as e:\n"
            "        raise ValueError(f'Invalid token: {e}')\n\n"
            "    if payload.get('type') != token_type:\n"
            "        raise ValueError(f'Expected {token_type} token, got {payload.get(\"type\")}')\n\n"
            "    return payload\n\n\n"
            "# â”€â”€ Flask Integration Example â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "def require_auth(f):\n"
            "    \"\"\"Flask decorator for JWT-protected endpoints.\"\"\"\n"
            "    from functools import wraps\n"
            "    from flask import request, jsonify\n\n"
            "    @wraps(f)\n"
            "    def decorated(*args, **kwargs):\n"
            "        auth = request.headers.get('Authorization', '')\n"
            "        if not auth.startswith('Bearer '):\n"
            "            return jsonify({'error': 'Missing Authorization header'}), 401\n"
            "        token = auth.split(' ', 1)[1]\n"
            "        try:\n"
            "            payload = verify_token(token, token_type='access')\n"
            "        except ValueError as e:\n"
            "            return jsonify({'error': str(e)}), 401\n"
            "        request.user_id = payload['sub']\n"
            "        return f(*args, **kwargs)\n"
            "    return decorated\n\n\n"
            "# â”€â”€ Secret Rotation Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "def rotate_secret_verify(token: str, old_secret: str, new_secret: str) -> str:\n"
            "    \"\"\"Decode with old secret, re-sign with new secret for zero-downtime rotation.\"\"\"\n"
            "    payload = jwt.decode(token, old_secret, algorithms=[ALGORITHM])\n"
            "    payload.pop('iat', None)  # will be set fresh\n"
            "    return jwt.encode(payload, new_secret, algorithm=ALGORITHM)\n"
            "```\n\n"
            "**Security checklist:**\n"
            "- âœ… Algorithm pinned â€” prevents `alg:none` attack\n"
            "- âœ… Short-lived access tokens (15 min default)\n"
            "- âœ… `jti` claim for token revocation (store in Redis blocklist)\n"
            "- âœ… Token type validation â€” prevents refresh token re-use as access\n"
            "- âœ… `nbf` checked â€” prevents future-dated tokens\n"
            "- âœ… Secret length enforced â‰¥ 32 chars"
        ),
    },
    {
        "category": "network_security",
        "user": "Write a Python script to detect ARP spoofing / Man-in-the-Middle attacks on a local network.",
        "assistant": (
            "âš ï¸ **Authorization Warning:** Only run on networks you own or have permission to monitor.\n\n"
            "```python\n"
            "#!/usr/bin/env python3\n"
            "\"\"\"\n"
            "ARP Spoof Detector â€” Hancock CyberViser\n"
            "Detects ARP spoofing (MitM) by monitoring ARP table inconsistencies.\n"
            "\n"
            "Usage:\n"
            "    sudo python arp_detector.py -i eth0\n"
            "    sudo python arp_detector.py -i eth0 --alert-webhook https://hooks.slack.com/...\n"
            "\n"
            "Requirements: pip install scapy requests\n"
            "\"\"\"\n"
            "import argparse\n"
            "import json\n"
            "import os\n"
            "import sys\n"
            "import time\n"
            "from collections import defaultdict\n"
            "from datetime import datetime\n\n"
            "try:\n"
            "    from scapy.all import ARP, sniff, get_if_hwaddr\n"
            "except ImportError:\n"
            "    sys.exit(\"Install: pip install scapy\")\n\n\n"
            "if os.geteuid() != 0:\n"
            "    sys.exit(\"ERROR: Must run as root (sudo) for packet capture.\")\n\n\n"
            "class ARPMonitor:\n"
            "    \"\"\"Monitors ARP traffic and detects MAC/IP binding changes.\"\"\"\n\n"
            "    def __init__(self, interface: str, webhook_url: str = None):\n"
            "        self.interface   = interface\n"
            "        self.webhook_url = webhook_url\n"
            "        self.arp_table: dict[str, str] = {}  # ip â†’ mac\n"
            "        self.alert_count = 0\n\n"
            "    def process_arp(self, packet):\n"
            "        \"\"\"Process captured ARP packet.\"\"\"\n"
            "        if packet.haslayer(ARP) and packet[ARP].op == 2:  # ARP reply\n"
            "            src_ip  = packet[ARP].psrc\n"
            "            src_mac = packet[ARP].hwsrc.lower()\n\n"
            "            known_mac = self.arp_table.get(src_ip)\n"
            "            if known_mac and known_mac != src_mac:\n"
            "                self._alert(src_ip, known_mac, src_mac)\n"
            "            else:\n"
            "                self.arp_table[src_ip] = src_mac\n\n"
            "    def _alert(self, ip: str, old_mac: str, new_mac: str):\n"
            "        \"\"\"Generate and log ARP spoof alert.\"\"\"\n"
            "        self.alert_count += 1\n"
            "        alert = {\n"
            "            'timestamp': datetime.utcnow().isoformat() + 'Z',\n"
            "            'type':      'ARP_SPOOF',\n"
            "            'severity':  'CRITICAL',\n"
            "            'ip':        ip,\n"
            "            'old_mac':   old_mac,\n"
            "            'new_mac':   new_mac,\n"
            "            'message':   f'ARP spoof detected: {ip} changed from {old_mac} to {new_mac}',\n"
            "        }\n"
            "        print(f\"\\n[!] ALERT #{self.alert_count}: {alert['message']}\")\n"
            "        print(f\"    Possible MitM â€” attacker MAC: {new_mac}\")\n\n"
            "        if self.webhook_url:\n"
            "            try:\n"
            "                import requests\n"
            "                requests.post(self.webhook_url,\n"
            "                              json={'text': alert['message']},\n"
            "                              timeout=5)\n"
            "            except Exception as e:\n"
            "                print(f\"    Webhook error: {e}\")\n\n"
            "    def start(self):\n"
            "        \"\"\"Start ARP capture loop.\"\"\"\n"
            "        print(f\"[*] ARP Spoof Detector on {self.interface} â€” Ctrl+C to stop\")\n"
            "        print(f\"[*] Building ARP table baseline...\")\n"
            "        sniff(\n"
            "            iface=self.interface,\n"
            "            filter='arp',\n"
            "            prn=self.process_arp,\n"
            "            store=False,\n"
            "        )\n\n\n"
            "def main():\n"
            "    parser = argparse.ArgumentParser(description=\"ARP Spoof Detector â€” Hancock\")\n"
            "    parser.add_argument('-i', '--interface', default='eth0')\n"
            "    parser.add_argument('--alert-webhook', help='Slack/Teams webhook URL for alerts')\n"
            "    args = parser.parse_args()\n\n"
            "    monitor = ARPMonitor(args.interface, args.alert_webhook)\n"
            "    try:\n"
            "        monitor.start()\n"
            "    except KeyboardInterrupt:\n"
            "        print(f\"\\n[*] Stopped. {monitor.alert_count} alerts generated.\")\n\n\n"
            "if __name__ == '__main__':\n"
            "    main()\n"
            "```"
        ),
    },
    {
        "category": "powershell",
        "user": "Write a PowerShell script to audit Active Directory for security misconfigurations: password policy, privileged accounts, stale accounts.",
        "assistant": (
            "```powershell\n"
            "# AD Security Audit â€” Hancock CyberViser\n"
            "# Audits AD for common misconfigurations\n"
            "# Requirements: AD PowerShell module (RSAT)\n"
            "# Run as: .\\ad_audit.ps1 | Out-File ad_audit_report.txt\n\n"
            "#Requires -Modules ActiveDirectory\n\n"
            "$ErrorActionPreference = 'SilentlyContinue'\n"
            "function Write-Section ($title) {\n"
            "    Write-Host \"`n[+] $title\" -ForegroundColor Yellow\n"
            "    Write-Host ('â”€' * 50) -ForegroundColor DarkGray\n"
            "}\n"
            "function Write-Hit ($msg) { Write-Host \"  [!] $msg\" -ForegroundColor Red }\n"
            "function Write-Info ($msg) { Write-Host \"  [*] $msg\" -ForegroundColor Cyan }\n\n"
            "Write-Host \"=== Active Directory Security Audit ===\"  -ForegroundColor Red\n"
            "Write-Host \"  Domain: $((Get-ADDomain).DNSRoot)\"\n"
            "Write-Host \"  Date  : $(Get-Date -Format 'yyyy-MM-dd HH:mm')\"\n\n"
            "# â”€â”€ 1. Default Domain Password Policy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "Write-Section '1. Default Password Policy'\n"
            "$policy = Get-ADDefaultDomainPasswordPolicy\n"
            "Write-Info \"Min length    : $($policy.MinPasswordLength)  (recommend: â‰¥14)\"\n"
            "Write-Info \"Max age (days): $($policy.MaxPasswordAge.Days)  (recommend: â‰¤90)\"\n"
            "Write-Info \"Complexity    : $($policy.ComplexityEnabled)\"\n"
            "Write-Info \"Lockout thresh: $($policy.LockoutThreshold)  (recommend: â‰¤5)\"\n"
            "if ($policy.MinPasswordLength -lt 14)  { Write-Hit 'Password min length < 14!' }\n"
            "if (!$policy.ComplexityEnabled)          { Write-Hit 'Complexity NOT enabled!' }\n"
            "if ($policy.LockoutThreshold -eq 0)      { Write-Hit 'Account lockout DISABLED!' }\n"
            "if ($policy.ReversibleEncryptionEnabled) { Write-Hit 'Reversible encryption ENABLED!' }\n\n"
            "# â”€â”€ 2. Privileged Account Audit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "Write-Section '2. Domain Admin Accounts'\n"
            "$domainAdmins = Get-ADGroupMember 'Domain Admins' -Recursive |\n"
            "    Where-Object { $_.objectClass -eq 'user' }\n"
            "Write-Info \"Domain Admin count: $($domainAdmins.Count)  (recommend: â‰¤5)\"\n"
            "if ($domainAdmins.Count -gt 5) { Write-Hit \"Too many Domain Admins: $($domainAdmins.Count)\" }\n"
            "foreach ($admin in $domainAdmins) {\n"
            "    $user = Get-ADUser $admin -Properties PasswordLastSet, LastLogonDate, Enabled\n"
            "    $pwAge = (New-TimeSpan -Start $user.PasswordLastSet -End (Get-Date)).Days\n"
            "    if ($pwAge -gt 180) { Write-Hit \"DA stale password ($pwAge days): $($user.SamAccountName)\" }\n"
            "    if (!$user.Enabled)  { Write-Hit \"DISABLED DA still in group: $($user.SamAccountName)\" }\n"
            "}\n\n"
            "# â”€â”€ 3. Stale / Inactive Accounts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "Write-Section '3. Stale Accounts (90+ days inactive)'\n"
            "$cutoff = (Get-Date).AddDays(-90)\n"
            "$stale  = Get-ADUser -Filter {Enabled -eq $true -and LastLogonDate -lt $cutoff -and LastLogonDate -ne $null} `\n"
            "                      -Properties LastLogonDate, PasswordLastSet | Sort-Object LastLogonDate\n"
            "Write-Info \"Stale enabled accounts: $($stale.Count)\"\n"
            "if ($stale.Count -gt 0) {\n"
            "    Write-Hit \"$($stale.Count) accounts inactive 90+ days â€” review and disable\"\n"
            "    $stale | Select-Object SamAccountName, LastLogonDate | Format-Table\n"
            "}\n\n"
            "# â”€â”€ 4. Accounts with Password Never Expires â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "Write-Section '4. Password Never Expires'\n"
            "$neverExpire = Get-ADUser -Filter {PasswordNeverExpires -eq $true -and Enabled -eq $true} `\n"
            "                           -Properties PasswordNeverExpires\n"
            "Write-Info \"Count: $($neverExpire.Count)\"\n"
            "if ($neverExpire.Count -gt 0) {\n"
            "    Write-Hit \"Accounts with PasswordNeverExpires:\"\n"
            "    $neverExpire | Select-Object SamAccountName | Format-Table\n"
            "}\n\n"
            "# â”€â”€ 5. Kerberoastable Accounts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "Write-Section '5. Kerberoastable Service Accounts (SPN set + not managed)'\n"
            "$kerberoastable = Get-ADUser -Filter {ServicePrincipalName -ne '$null' -and Enabled -eq $true} `\n"
            "                              -Properties ServicePrincipalName\n"
            "if ($kerberoastable.Count -gt 0) {\n"
            "    Write-Hit \"$($kerberoastable.Count) Kerberoastable user accounts:\"\n"
            "    $kerberoastable | Select-Object SamAccountName, ServicePrincipalName | Format-Table\n"
            "}\n\n"
            "# â”€â”€ 6. AS-REP Roastable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "Write-Section '6. AS-REP Roastable (Pre-auth not required)'\n"
            "$asrep = Get-ADUser -Filter {DoesNotRequirePreAuth -eq $true -and Enabled -eq $true}\n"
            "if ($asrep.Count -gt 0) {\n"
            "    Write-Hit \"$($asrep.Count) AS-REP Roastable accounts:\"\n"
            "    $asrep | Select-Object SamAccountName | Format-Table\n"
            "}\n\n"
            "Write-Host \"`n[*] Audit complete.\" -ForegroundColor Green\n"
            "```"
        ),
    },
    {
        "category": "security_automation",
        "user": "Write a Python script that tails Nginx access logs and blocks IPs showing attack patterns (brute force, scanner, SQLi).",
        "assistant": (
            "```python\n"
            "#!/usr/bin/env python3\n"
            "\"\"\"\n"
            "Nginx Attack Blocker â€” Hancock CyberViser\n"
            "Tails Nginx access logs and auto-blocks attacking IPs via iptables/ufw.\n"
            "\n"
            "Usage (must run as root):\n"
            "    sudo python nginx_blocker.py --log /var/log/nginx/access.log\n"
            "    sudo python nginx_blocker.py --log /var/log/nginx/access.log --dry-run\n"
            "\"\"\"\n"
            "import argparse\n"
            "import os\n"
            "import re\n"
            "import subprocess\n"
            "import sys\n"
            "import time\n"
            "from collections import defaultdict\n"
            "from dataclasses import dataclass, field\n"
            "from datetime import datetime, timedelta\n\n\n"
            "# Detection thresholds\n"
            "BRUTE_FORCE_THRESHOLD  = 20   # 401/403 responses in window\n"
            "SCANNER_THRESHOLD      = 50   # 404 responses in window\n"
            "SQLI_PATTERNS = re.compile(\n"
            "    r'(union.*select|select.*from|insert.*into|drop.*table'\n"
            "    r'|or.*1.*=.*1|and.*1.*=.*1|xp_cmdshell|exec.*sp_|sleep\\(\\d+\\)'\n"
            "    r'|benchmark\\(|--.*$|;\\/\\*|0x[0-9a-f]{4,})',\n"
            "    re.IGNORECASE\n"
            ")\n"
            "TIME_WINDOW = 300  # seconds\n"
            "LOG_PATTERN = re.compile(\n"
            "    r'(?P<ip>\\d+\\.\\d+\\.\\d+\\.\\d+) .+ \"(?P<method>\\S+) (?P<path>\\S+) '\n"
            "    r'HTTP[^\"]*\" (?P<status>\\d+) (?P<bytes>\\d+)'\n"
            ")\n\n\n"
            "@dataclass\n"
            "class IPStats:\n"
            "    hits:     list = field(default_factory=list)\n"
            "    errors_4xx: int = 0\n"
            "    errors_404: int = 0\n"
            "    sqli_hits:  int = 0\n"
            "    blocked:  bool = False\n\n\n"
            "class NginxBlocker:\n"
            "    def __init__(self, log_path: str, dry_run: bool = False):\n"
            "        self.log_path  = log_path\n"
            "        self.dry_run   = dry_run\n"
            "        self.ip_stats: dict[str, IPStats] = defaultdict(IPStats)\n"
            "        self.whitelist = {'127.0.0.1', '::1', '10.0.0.1'}\n\n"
            "    def parse_line(self, line: str) -> dict | None:\n"
            "        m = LOG_PATTERN.search(line)\n"
            "        return m.groupdict() if m else None\n\n"
            "    def should_block(self, ip: str) -> tuple[bool, str]:\n"
            "        \"\"\"Check if IP should be blocked and return reason.\"\"\"\n"
            "        stats = self.ip_stats[ip]\n"
            "        now = time.time()\n"
            "        # Prune old hits outside window\n"
            "        stats.hits = [t for t in stats.hits if now - t < TIME_WINDOW]\n\n"
            "        if stats.sqli_hits >= 3:\n"
            "            return True, f'SQLi attempt ({stats.sqli_hits} hits)'\n"
            "        if stats.errors_4xx >= BRUTE_FORCE_THRESHOLD:\n"
            "            return True, f'Brute force ({stats.errors_4xx} 401/403s)'\n"
            "        if stats.errors_404 >= SCANNER_THRESHOLD:\n"
            "            return True, f'Scanner ({stats.errors_404} 404s)'\n"
            "        return False, ''\n\n"
            "    def block_ip(self, ip: str, reason: str):\n"
            "        \"\"\"Block IP via iptables.\"\"\"\n"
            "        print(f\"[!] BLOCKING {ip} â€” {reason}\")\n"
            "        if not self.dry_run:\n"
            "            subprocess.run(\n"
            "                ['iptables', '-A', 'INPUT', '-s', ip, '-j', 'DROP'],\n"
            "                check=True, capture_output=True\n"
            "            )\n"
            "        self.ip_stats[ip].blocked = True\n\n"
            "    def process_line(self, line: str):\n"
            "        record = self.parse_line(line)\n"
            "        if not record:\n"
            "            return\n"
            "        ip     = record['ip']\n"
            "        status = int(record['status'])\n"
            "        path   = record['path']\n\n"
            "        if ip in self.whitelist:\n"
            "            return\n"
            "        stats = self.ip_stats[ip]\n"
            "        if stats.blocked:\n"
            "            return\n\n"
            "        stats.hits.append(time.time())\n"
            "        if status in (401, 403):\n"
            "            stats.errors_4xx += 1\n"
            "        if status == 404:\n"
            "            stats.errors_404 += 1\n"
            "        if SQLI_PATTERNS.search(path):\n"
            "            stats.sqli_hits += 1\n\n"
            "        should, reason = self.should_block(ip)\n"
            "        if should:\n"
            "            self.block_ip(ip, reason)\n\n"
            "    def tail(self):\n"
            "        \"\"\"Tail the log file and process new lines.\"\"\"\n"
            "        print(f\"[*] Watching {self.log_path} ({'DRY RUN' if self.dry_run else 'LIVE'})\")\n"
            "        with open(self.log_path) as f:\n"
            "            f.seek(0, 2)  # seek to end\n"
            "            while True:\n"
            "                line = f.readline()\n"
            "                if line:\n"
            "                    self.process_line(line.strip())\n"
            "                else:\n"
            "                    time.sleep(0.1)\n\n\n"
            "def main():\n"
            "    if os.geteuid() != 0 and not ('--dry-run' in sys.argv):\n"
            "        print(\"Warning: Run as root to actually block IPs.\")\n"
            "    parser = argparse.ArgumentParser(description=\"Nginx Attack Blocker â€” Hancock\")\n"
            "    parser.add_argument('--log', default='/var/log/nginx/access.log')\n"
            "    parser.add_argument('--dry-run', action='store_true', help=\"Don't actually block\")\n"
            "    args = parser.parse_args()\n"
            "    NginxBlocker(args.log, args.dry_run).tail()\n\n\n"
            "if __name__ == '__main__':\n"
            "    main()\n"
            "```"
        ),
    },
    {
        "category": "secure_coding",
        "user": "Write a Python function for secure password hashing and verification using Argon2id.",
        "assistant": (
            "```python\n"
            "\"\"\"\n"
            "Secure Password Hashing â€” Hancock CyberViser\n"
            "Uses Argon2id (OWASP recommended), the winner of the Password Hashing Competition.\n"
            "Requirements: pip install argon2-cffi\n"
            "\"\"\"\n"
            "import os\n"
            "import secrets\n"
            "from argon2 import PasswordHasher\n"
            "from argon2.exceptions import VerifyMismatchError, VerificationError, InvalidHashError\n\n\n"
            "# OWASP recommended Argon2id parameters (2023)\n"
            "# Time cost: 2 iterations | Memory: 19 MiB | Parallelism: 1\n"
            "_ph = PasswordHasher(\n"
            "    time_cost=2,\n"
            "    memory_cost=19456,   # 19 MiB\n"
            "    parallelism=1,\n"
            "    hash_len=32,\n"
            "    salt_len=16,\n"
            "    encoding='utf-8',\n"
            ")\n\n\n"
            "def hash_password(password: str) -> str:\n"
            "    \"\"\"\n"
            "    Hash a password with Argon2id.\n"
            "    Returns a self-contained hash string (includes salt + params).\n\n"
            "    Security properties:\n"
            "    - Argon2id is memory-hard (GPU cracking is expensive)\n"
            "    - Salt is random per password (rainbow tables useless)\n"
            "    - Hash embeds algorithm params for future migration\n"
            "    \"\"\"\n"
            "    if not isinstance(password, str) or len(password) < 1:\n"
            "        raise ValueError('Password must be a non-empty string')\n"
            "    if len(password) > 1000:\n"
            "        # Argon2 is immune to bcrypt's 72-byte limit, but cap to prevent DoS\n"
            "        raise ValueError('Password too long (max 1000 chars)')\n"
            "    return _ph.hash(password)\n\n\n"
            "def verify_password(plain: str, hashed: str) -> bool:\n"
            "    \"\"\"\n"
            "    Verify a password against its hash.\n"
            "    Returns True if valid, False if invalid.\n"
            "    Raises ValueError for malformed hashes.\n\n"
            "    Note: Always use constant-time comparison (argon2-cffi does this internally).\n"
            "    \"\"\"\n"
            "    try:\n"
            "        return _ph.verify(hashed, plain)\n"
            "    except VerifyMismatchError:\n"
            "        return False  # Wrong password\n"
            "    except (VerificationError, InvalidHashError) as e:\n"
            "        raise ValueError(f'Hash verification error: {e}')\n\n\n"
            "def needs_rehash(hashed: str) -> bool:\n"
            "    \"\"\"\n"
            "    Check if hash needs upgrading (params changed).\n"
            "    Call after successful verification and rehash if True.\n"
            "    \"\"\"\n"
            "    return _ph.check_needs_rehash(hashed)\n\n\n"
            "# â”€â”€ Example login flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "def login(plain_password: str, stored_hash: str) -> tuple[bool, str | None]:\n"
            "    \"\"\"\n"
            "    Full login flow with rehash-on-upgrade.\n"
            "    Returns (success, new_hash_if_rehashed_else_None)\n"
            "    \"\"\"\n"
            "    if not verify_password(plain_password, stored_hash):\n"
            "        return False, None\n"
            "    # Upgrade hash if params are outdated\n"
            "    if needs_rehash(stored_hash):\n"
            "        return True, hash_password(plain_password)  # caller must persist new hash\n"
            "    return True, None\n\n\n"
            "# â”€â”€ DO NOT USE (insecure examples for comparison) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "# âŒ hashlib.md5(password.encode()).hexdigest()   â€” not suitable for passwords\n"
            "# âŒ hashlib.sha256(password.encode()).hexdigest() â€” not suitable for passwords\n"
            "# âŒ bcrypt (72-byte limit, not memory-hard)\n"
            "# âœ… Use Argon2id (this module), bcrypt if Argon2 unavailable, scrypt as fallback\n"
            "```\n\n"
            "**OWASP password storage cheat sheet:**\n"
            "1. Argon2id with mâ‰¥19MiB, tâ‰¥2, p=1 â€” preferred\n"
            "2. bcrypt with costâ‰¥10 â€” acceptable (72-byte limit)\n"
            "3. scrypt with N=2^17, r=8, p=1 â€” acceptable\n"
            "4. PBKDF2-SHA512 with â‰¥600,000 iterations â€” only if above unavailable"
        ),
    },
    {
        "category": "bash_scripting",
        "user": "Write a Bash script to automate Linux privilege escalation enumeration (like LinPEAS but simpler).",
        "assistant": (
            "âš ï¸ **Authorization Warning:** Only use on systems you own or have explicit permission to test.\n\n"
            "```bash\n"
            "#!/usr/bin/env bash\n"
            "# linux_enum.sh â€” Linux Privilege Escalation Enumerator\n"
            "# Hancock / CyberViser â€” Authorized use only\n"
            "# Usage: bash linux_enum.sh 2>/dev/null | tee enum_output.txt\n\n"
            "RED='\\033[0;31m'; YLW='\\033[0;33m'; GRN='\\033[0;32m'; NC='\\033[0m'\n"
            "section() { echo -e \"\\n${YLW}[+] $1${NC}\"; echo 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'; }\n"
            "hit()     { echo -e \"  ${RED}[!] $1${NC}\"; }\n"
            "info()    { echo -e \"  ${GRN}[*] $1${NC}\"; }\n\n"
            "echo -e \"${RED}=== Linux Privilege Escalation Enumeration ===${NC}\"\n"
            "echo \"  User: $(whoami) | Host: $(hostname) | Date: $(date)\"\n\n"
            "# â”€â”€ System Information â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"System Information\"\n"
            "uname -a\n"
            "cat /etc/os-release 2>/dev/null | head -5\n"
            "lscpu | grep 'Model name' 2>/dev/null\n\n"
            "# â”€â”€ Current User Context â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"User & Privileges\"\n"
            "id\n"
            "echo \"Groups: $(groups)\"\n"
            "echo \"Home: $HOME\"\n"
            "[[ $(id -u) -eq 0 ]] && hit \"RUNNING AS ROOT!\"\n\n"
            "# â”€â”€ Sudo Permissions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"Sudo Permissions\"\n"
            "sudo -l 2>/dev/null && hit \"Sudo entries found â€” check GTFOBins!\"\n\n"
            "# â”€â”€ SUID Binaries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"SUID Binaries\"\n"
            "find / -perm -4000 -type f 2>/dev/null | while read f; do\n"
            "    hit \"SUID: $f\"\n"
            "done\n\n"
            "# â”€â”€ SGID Binaries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"SGID Binaries\"\n"
            "find / -perm -2000 -type f 2>/dev/null | while read f; do\n"
            "    info \"SGID: $f\"\n"
            "done\n\n"
            "# â”€â”€ World-Writable Files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"World-Writable Sensitive Files\"\n"
            "for f in /etc/passwd /etc/shadow /etc/sudoers /etc/crontab; do\n"
            "    [[ -w \"$f\" ]] && hit \"Writable: $f\"\n"
            "done\n\n"
            "# â”€â”€ Cron Jobs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"Cron Jobs\"\n"
            "cat /etc/crontab 2>/dev/null\n"
            "ls -la /etc/cron.* 2>/dev/null\n"
            "crontab -l 2>/dev/null\n"
            "# Look for writable scripts called by cron\n"
            "grep -r '\\*.*/' /etc/cron* /var/spool/cron 2>/dev/null | grep -v '^#' | while read line; do\n"
            "    script=$(echo \"$line\" | awk '{print $NF}')\n"
            "    [[ -w \"$script\" ]] && hit \"Writable cron script: $script\"\n"
            "done\n\n"
            "# â”€â”€ Capabilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"Linux Capabilities\"\n"
            "getcap -r / 2>/dev/null | while read line; do\n"
            "    hit \"Capability: $line\"\n"
            "done\n\n"
            "# â”€â”€ Services & Network â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"Listening Services\"\n"
            "ss -tlnp 2>/dev/null || netstat -tlnp 2>/dev/null\n\n"
            "# â”€â”€ Environment Variables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"Interesting Environment Variables\"\n"
            "env | grep -iE 'pass|key|secret|token|api|cred' 2>/dev/null | while read e; do\n"
            "    hit \"Env cred: $e\"\n"
            "done\n\n"
            "# â”€â”€ Config Files with Credentials â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            "section \"Config Files (Potential Credentials)\"\n"
            "for pattern in password passwd api_key secret token; do\n"
            "    grep -r \"$pattern\" /home /etc /var/www 2>/dev/null --include='*.conf' \\\n"
            "        --include='*.yml' --include='*.env' --include='*.ini' -l | while read f; do\n"
            "        hit \"Possible creds in: $f\"\n"
            "    done\n"
            "done\n\n"
            "echo -e \"\\n${GRN}[*] Enumeration complete. Cross-reference findings with GTFOBins.${NC}\"\n"
            "echo \"    https://gtfobins.github.io/\"\n"
            "```"
        ),
    },
]


def generate():
    samples = []
    for item in KB:
        samples.append({
            "messages": [
                {"role": "system",    "content": HANCOCK_SYSTEM},
                {"role": "user",      "content": item["user"]},
                {"role": "assistant", "content": item["assistant"]},
            ]
        })
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT_FILE, "w") as f:
        json.dump(samples, f, indent=2)
    print(f"[code_kb] âœ… {len(samples)} samples â†’ {OUTPUT_FILE}")
    return samples


if __name__ == "__main__":
    generate()
